/**
 * @file RRTOS_simplified_demo.cpp
 * @brief RRTOS简化接口演示程序
 * @author Generated by AI Assistant
 * @date 2025-05-15
 * @details 演示如何使用精简版RRTOS系统进行话题和服务通信
 */

#include <Arduino.h>
#include "RRTOS.h"

// 自定义消息类型
struct SensorData {
    float temperature;
    float humidity;
    float pressure;
    
    SensorData() : temperature(0), humidity(0), pressure(0) {}
    SensorData(float t, float h, float p) : temperature(t), humidity(h), pressure(p) {}
};

// 自定义服务请求和响应类型
struct MotorControlRequest {
    int motorId;
    float speed;
    bool enable;
    
    MotorControlRequest() : motorId(0), speed(0), enable(false) {}
    MotorControlRequest(int id, float s, bool e) : motorId(id), speed(s), enable(e) {}
};

struct MotorControlResponse {
    bool success;
    String message;
    
    MotorControlResponse() : success(false), message("") {}
    MotorControlResponse(bool s, String m) : success(s), message(m) {}
};

// 话题发布任务
void publisherTask(void* params) {
    // 延迟2秒，确保系统初始化完成
    vTaskDelay(pdMS_TO_TICKS(2000));
    Serial.println("发布者任务启动");
    
    // 创建不同类型的发布者，直接使用类型模板
    auto intPub = RRTOS::pub<int>("int_topic");
    auto floatPub = RRTOS::pub<float>("float_topic");
    auto sensorPub = RRTOS::pub<SensorData>("sensor_topic");
    
    int counter = 0;
    float value = 0.0f;
    
    while (true) {
        // 发布整数数据，直接传递数据而不是消息对象
        bool intResult = intPub.publish(counter);
        Serial.printf("发布整数数据: %d, 结果: %s\n", counter, 
                      intResult ? "成功" : "失败");
        
        // 也可以使用advertise方法（它现在只是publish的别名）
        bool floatResult = floatPub.advertise(value);
        Serial.printf("发布浮点数数据: %.2f, 结果: %s\n", value,
                      floatResult ? "成功" : "失败");
        
        // 创建并直接发布传感器数据，无需额外包装
        SensorData sensorData(25.0 + sin(value), 50.0 + cos(value), 1013.25);
        bool sensorResult = sensorPub.publish(sensorData);
        Serial.printf("发布传感器数据: 温度=%.1f, 湿度=%.1f, 气压=%.2f, 结果: %s\n", 
                      sensorData.temperature, sensorData.humidity, sensorData.pressure,
                      sensorResult ? "成功" : "失败");
        
        // 更新计数器和值
        counter++;
        value += 0.1;
        
        // 每2秒发布一次
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

// 话题订阅者回调函数 - 直接接收数据类型，而不是消息对象
void intCallback(const int& value) {
    Serial.printf("收到整数数据: %d\n", value);
}

void floatCallback(const float& value) {
    Serial.printf("收到浮点数数据: %.2f\n", value);
}

void sensorCallback(const SensorData& data) {
    Serial.printf("收到传感器数据: 温度=%.1f, 湿度=%.1f, 气压=%.2f\n",
                  data.temperature, data.humidity, data.pressure);
}

// 话题订阅任务
void subscriberTask(void* params) {
    // 延迟3秒，确保发布者已经创建话题
    vTaskDelay(pdMS_TO_TICKS(3000));
    Serial.println("订阅者任务启动");
    
    // 创建订阅者，直接订阅数据类型
    auto intSub = RRTOS::sub<int>("int_topic", intCallback);
    auto floatSub = RRTOS::sub<float>("float_topic", floatCallback);
    auto sensorSub = RRTOS::sub<SensorData>("sensor_topic", sensorCallback);
    
    // 订阅者会在自己的线程中运行回调，这里不需要做什么
    while (true) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// 电机控制服务回调，直接使用数据类型
bool motorServiceCallback(const MotorControlRequest& req, MotorControlResponse& resp) {
    Serial.printf("收到电机控制请求: 电机ID=%d, 速度=%.2f, 启用=%s\n",
                  req.motorId, req.speed, req.enable ? "是" : "否");
    
    // 模拟处理请求
    bool success = (req.motorId >= 0 && req.motorId < 4);
    
    // 设置响应
    resp.success = success;
    if (success) {
        resp.message = "电机控制成功";
    } else {
        resp.message = "无效的电机ID";
    }
    
    return true;
}

// 服务器任务
void serverTask(void* params) {
    // 延迟4秒，确保系统初始化完成
    vTaskDelay(pdMS_TO_TICKS(4000));
    Serial.println("服务器任务启动");
    
    // 创建电机控制服务，直接使用数据类型
    auto motorServer = RRTOS::advertiseService<MotorControlRequest, MotorControlResponse>(
        "motor_control", motorServiceCallback);
    
    // 服务器会在自己的线程中处理请求，这里不需要做什么
    while (true) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// 客户端任务
void clientTask(void* params) {
    // 延迟5秒，确保服务器已经启动
    vTaskDelay(pdMS_TO_TICKS(5000));
    Serial.println("客户端任务启动");
    
    // 创建电机控制客户端，直接使用数据类型
    auto motorClient = RRTOS::serviceClient<MotorControlRequest, MotorControlResponse>("motor_control");
    
    int requestCounter = 0;
    
    while (true) {
        // 准备请求和响应对象
        MotorControlRequest request(requestCounter % 5, 50.0 + requestCounter, true);
        MotorControlResponse response;
        
        // 直接调用服务，传递数据对象
        bool callResult = motorClient->call(request, response);
        
        if (callResult) {
            Serial.printf("服务调用成功: %s\n", response.message.c_str());
        } else {
            Serial.println("服务调用失败");
        }
        
        requestCounter++;
        
        // 每3秒调用一次服务
        vTaskDelay(pdMS_TO_TICKS(3000));
    }
}

// Arduino setup函数
void setup() {
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("\n===== RRTOS简化接口演示 =====");
    
    // 初始化RRTOS系统
    if (!RRTOS::initialize()) {
        Serial.println("错误: RRTOS系统初始化失败");
        return;
    }
    
    // 创建任务
    xTaskCreatePinnedToCore(publisherTask, "Publisher", 4096, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(subscriberTask, "Subscriber", 4096, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(serverTask, "Server", 4096, NULL, 1, NULL, 1);
    xTaskCreatePinnedToCore(clientTask, "Client", 4096, NULL, 1, NULL, 1);
    
    Serial.println("所有任务已启动");
}

void loop() {
    // 主循环中不需要做任何事情
    vTaskDelay(pdMS_TO_TICKS(1000));
}
