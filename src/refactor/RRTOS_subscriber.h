/**
 * @file RRTOS_subscriber.h
 * @brief RRTOS话题订阅者接口
 * @author Generated by AI Assistant
 * @date 2025-05-15
 * @details 提供RRTOS系统的话题订阅功能
 */

#ifndef RRTOS_SUBSCRIBER_H
#define RRTOS_SUBSCRIBER_H

#include "RRTOS_common.h"
#include <functional>

namespace RRTOS {

/**
 * @brief 话题订阅者类
 * @tparam T 订阅的数据类型
 */
template <typename T>
class Subscriber {
private:
    std::string topicName;       // 话题名称
    QueueHandle_t queueHandle;   // 队列句柄

public:
    /**
     * @brief 构造函数
     * @param topic 话题名称
     * @param handle 队列句柄
     */
    Subscriber(const std::string& topic, QueueHandle_t handle)
        : topicName(topic), queueHandle(handle) {}
    
    /**
     * @brief 析构函数
     */
    ~Subscriber() {}
    
    /**
     * @brief 获取话题名称
     * @return 话题名称
     */
    std::string getTopic() const {
        return topicName;
    }
      /**
     * @brief 阻塞式接收一条消息
     * @param msg 数据对象引用
     * @param timeout 超时时间（毫秒）
     * @return 是否接收成功
     */
    bool receive(T& msg, uint32_t timeout = portMAX_DELAY) {
        BaseType_t result = xQueueReceive(queueHandle, &msg, pdMS_TO_TICKS(timeout));
        return (result == pdTRUE);
    }
};

/**
 * @brief 创建订阅者
 * @tparam T 订阅的数据类型
 * @param topicName 话题名称
 * @return 订阅者对象指针
 */
template <typename T>
std::shared_ptr<Subscriber<T>> createSubscriber(const std::string& topicName) {
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(g_topicQueuesMutex, pdMS_TO_TICKS(100)) != pdTRUE) {
        Serial.println("警告: 无法获取话题互斥锁");
        return nullptr;
    }
    
    // 检查话题是否存在
    QueueHandle_t queueHandle = nullptr;
    auto it = g_topicQueues.find(topicName);
    if (it == g_topicQueues.end()) {
        Serial.printf("错误: 话题'%s'不存在，无法订阅\n", topicName.c_str());
        xSemaphoreGive(g_topicQueuesMutex);
        return nullptr;
    }
      queueHandle = it->second;
    xSemaphoreGive(g_topicQueuesMutex);
    
    // 创建订阅者
    auto subscriber = std::make_shared<Subscriber<T>>(topicName, queueHandle);
    
    return subscriber;
}

} // namespace RRTOS

#endif // RRTOS_SUBSCRIBER_H
