/**
 * @file RRTOS.h
 * @brief RRTOS系统总头文件
 * @author Generated by AI Assistant
 * @date 2025-05-15
 * @details 提供RRTOS系统的所有组件，模仿ROS接口，基于FreeRTOS实现
 */

#ifndef RRTOS_H
#define RRTOS_H

#include "RRTOS_common.h"
#include "RRTOS_publisher.h"
#include "RRTOS_subscriber.h"
#include "RRTOS_server.h"
#include "RRTOS_client.h"

namespace RRTOS {

/**
 * @brief 创建并获取发布者对象
 * @tparam T 消息数据类型
 * @param topicName 话题名称
 * @param config 队列配置
 * @return 发布者对象
 */
template <typename T>
Publisher pub(const std::string& topicName, const QueueConfig& config = QueueConfig()) {
    // 尝试获取互斥锁
    if (xSemaphoreTake(g_topicQueuesMutex, pdMS_TO_TICKS(100)) != pdTRUE) {
        Serial.println("警告: 无法获取话题互斥锁");
        // 假设没有互斥锁，创建一个不可用的发布者
        return Publisher(topicName, nullptr, 0);
    }
    
    // 检查话题是否已经存在
    QueueHandle_t queueHandle = nullptr;
    size_t itemSize = config.maxItemSize;
    
    auto it = g_topicQueues.find(topicName);
    if (it == g_topicQueues.end()) {
        // 话题不存在，创建新队列
    // 确保队列元素足够大以容纳数据类型
        size_t dataSize = sizeof(T);
        if (dataSize > itemSize) {
            itemSize = dataSize;
        }
        
        queueHandle = xQueueCreate(config.queueSize, itemSize);
        if (!queueHandle) {
            Serial.printf("错误: 无法为话题'%s'创建队列\n", topicName.c_str());
            xSemaphoreGive(g_topicQueuesMutex);
            return Publisher(topicName, nullptr, 0);
        }
        
        // 保存队列句柄
        g_topicQueues[topicName] = queueHandle;
    } else {
        // 话题已存在，获取队列句柄
        queueHandle = it->second;
    }
    
    xSemaphoreGive(g_topicQueuesMutex);
    
    // 创建并返回发布者
    return Publisher(topicName, queueHandle, itemSize);
}

/**
 * @brief 创建并获取订阅者对象
 * @tparam T 数据类型
 * @param topicName 话题名称
 * @return 订阅者对象指针
 */
template <typename T>
std::shared_ptr<Subscriber<T>> sub(const std::string& topicName) {
    return createSubscriber<T>(topicName);
}

/**
 * @brief 创建并获取服务器对象
 * @tparam ReqT 请求数据类型
 * @tparam RespT 响应数据类型
 * @param serviceName 服务名称
 * @param callback 服务回调函数
 * @param autoStart 是否自动启动服务器
 * @return 服务器对象指针
 */
template <typename ReqT, typename RespT>
std::shared_ptr<Server<ReqT, RespT>> advertiseService(
    const std::string& serviceName,
    typename Server<ReqT, RespT>::ServiceCallbackType callback,
    bool autoStart = true) {
        
    return createServer<ReqT, RespT>(serviceName, callback, autoStart);
}

/**
 * @brief 创建并获取客户端对象
 * @tparam ReqT 请求数据类型
 * @tparam RespT 响应数据类型
 * @param serviceName 服务名称
 * @return 客户端对象指针
 */
template <typename ReqT, typename RespT>
std::shared_ptr<Client<ReqT, RespT>> serviceClient(const std::string& serviceName) {
    return createClient<ReqT, RespT>(serviceName);
}

} // namespace RRTOS

#endif // RRTOS_H
