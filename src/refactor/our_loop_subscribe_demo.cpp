/**
 * @file our_loop_subscribe_demo.cpp
 * @brief 循环订阅演示
 * @author Generated by AI Assistant
 * @date 2025-05-19
 * @details 展示如何在循环中使用订阅，用于处理消息
 */

#include "our.h"
#include "../lib/our_queue/our_queque.hpp"

using namespace OUR;

// 定义消息类型
struct SensorData {
    float temperature;
    float humidity;
    uint32_t timestamp;
};

// 创建全局订阅者
std::shared_ptr<Subscriber<SensorData>> sensorSubscriber;

void setup() {
    Serial.begin(115200);
    delay(2000);
    
    Serial.println("循环订阅演示启动...");
    
    // 初始化系统
    OUR::init();
    
    // 创建发布者和订阅者
    auto publisher = OUR::pub<SensorData>("sensor_data");
    sensorSubscriber = OUR::sub<SensorData>("sensor_data");
    
    // 发布一些测试数据
    for (int i = 0; i < 5; i++) {
        SensorData data;
        data.temperature = 20.5f + i;
        data.humidity = 50.0f + i * 2.5f;
        data.timestamp = millis();
        
        publisher.publish(data, TASK_INA226, DATA_DESCRIPTION_VOLTAGE);
        delay(100);
    }
    
    Serial.println("已发布5条测试数据");
}

void loop() {
    // 在循环中非阻塞地检查消息
    QueueElement_t<SensorData> element;
    if (sensorSubscriber->receive(element, 0)) { // 0表示非阻塞检查
        Serial.println("接收到传感器数据:");
        Serial.printf("任务ID: %d, 数据描述: %d\n", element.task_id, element.data_description);
        Serial.printf("温度: %.1f°C, 湿度: %.1f%%\n", 
                    element.data.temperature, 
                    element.data.humidity);
        Serial.printf("时间戳: %u ms\n\n", element.data.timestamp);
    }
    
    // 也可以使用按任务ID过滤的接收方法
    SensorData filteredData;
    if (sensorSubscriber->receiveWithTaskId(filteredData, TASK_INA226, 0)) {
        Serial.println("接收到INA226传感器数据:");
        Serial.printf("温度: %.1f°C, 湿度: %.1f%%\n", 
                    filteredData.temperature, 
                    filteredData.humidity);
    }
    
    // 执行其他循环工作
    delay(500);
}
