/**
 * @file server.h
 * @brief 服务器接口
 * @author Generated by AI Assistant
 * @date 2025-05-19
 * @details 提供系统的服务器功能
 */

#ifndef SERVER_H
#define SERVER_H

#include "common.h"
#include <functional>

namespace OUR {

/**
 * @brief 服务器类模板
 * @tparam ReqT 请求数据类型
 * @tparam RespT 响应数据类型
 */
template <typename ReqT, typename RespT>
class Server {
public:
    using ServiceCallbackType = std::function<bool(const ReqT&, RespT&)>;

private:
    std::string serviceName;        // 服务名称
    QueueHandle_t requestQueue;     // 请求队列
    ServiceCallbackType callback;   // 服务回调函数
    TaskHandle_t serverTaskHandle;  // 服务任务句柄
    bool isRunning;                 // 是否正在运行
    
    /**
     * @brief 服务处理任务函数
     * @param params 参数（Server对象指针）
     */
    static void serverTask(void* params) {
        Server<ReqT, RespT>* self = static_cast<Server<ReqT, RespT>*>(params);
        ServicePair<ReqT, RespT>* servicePair = nullptr;
        
        while (self->isRunning) {
            // 等待请求
            if (xQueueReceive(self->requestQueue, &servicePair, pdMS_TO_TICKS(100)) == pdTRUE) {
                if (servicePair) {
                    // 调用回调处理请求
                    bool success = false;
                    if (self->callback) {
                        success = self->callback(servicePair->request, servicePair->response);
                    }
                    
                    // 标记完成
                    xSemaphoreGive(servicePair->done);
                }
            }
        }
        
        // 任务结束，自行删除
        vTaskDelete(NULL);
    }

public:
    /**
     * @brief 构造函数
     * @param name 服务名称
     * @param cb 服务回调函数
     */
    Server(const std::string& name, ServiceCallbackType cb)
        : serviceName(name), callback(cb), serverTaskHandle(nullptr), isRunning(false) {
        
        // 创建请求队列
        requestQueue = xQueueCreate(10, sizeof(ServicePair<ReqT, RespT>*));
        
        // 尝试获取互斥锁
        if (xSemaphoreTake(g_serviceSemaphoresMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            // 注册服务
            g_serviceSemaphores[serviceName] = xSemaphoreCreateBinary();
            xSemaphoreGive(g_serviceSemaphoresMutex);
        }
    }
    
    /**
     * @brief 析构函数
     */
    ~Server() {
        shutdown();
        
        // 删除队列
        if (requestQueue) {
            vQueueDelete(requestQueue);
            requestQueue = nullptr;
        }
        
        // 尝试获取互斥锁
        if (xSemaphoreTake(g_serviceSemaphoresMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            // 注销服务
            auto it = g_serviceSemaphores.find(serviceName);
            if (it != g_serviceSemaphores.end()) {
                vSemaphoreDelete(it->second);
                g_serviceSemaphores.erase(it);
            }
            xSemaphoreGive(g_serviceSemaphoresMutex);
        }
    }
    
    /**
     * @brief 启动服务器
     * @param stackSize 任务栈大小
     * @param priority 任务优先级
     * @param core 运行的核心
     * @return 是否启动成功
     */
    bool start(uint32_t stackSize = 4096, UBaseType_t priority = 1, BaseType_t core = tskNO_AFFINITY) {
        if (isRunning) {
            return true; // 已经在运行了
        }
        
        isRunning = true;
        
        // 创建服务任务
        BaseType_t result = xTaskCreatePinnedToCore(
            serverTask,
            ("Srv_" + serviceName).c_str(),
            stackSize,
            this,
            priority,
            &serverTaskHandle,
            core
        );
        
        return (result == pdPASS);
    }
    
    /**
     * @brief 关闭服务器
     */
    void shutdown() {
        isRunning = false;
        
        // 等待任务自行退出
        vTaskDelay(pdMS_TO_TICKS(200));
        
        serverTaskHandle = nullptr;
    }
    
    /**
     * @brief 获取服务名称
     * @return 服务名称
     */
    std::string getName() const {
        return serviceName;
    }
    
    /**
     * @brief 获取请求队列句柄
     * @return 队列句柄
     */
    QueueHandle_t getRequestQueue() const {
        return requestQueue;
    }
};

/**
 * @brief 创建服务器
 * @tparam ReqT 请求数据类型
 * @tparam RespT 响应数据类型
 * @param serviceName 服务名称
 * @param callback 服务回调函数
 * @param autoStart 是否自动启动服务器
 * @return 服务器对象指针
 */
template <typename ReqT, typename RespT>
std::shared_ptr<Server<ReqT, RespT>> createServer(
    const std::string& serviceName,
    typename Server<ReqT, RespT>::ServiceCallbackType callback,
    bool autoStart = true) {
    
    auto server = std::make_shared<Server<ReqT, RespT>>(serviceName, callback);
    
    // 如果需要自动启动
    if (autoStart) {
        server->start();
    }
    
    return server;
}

} // namespace OUR

#endif // SERVER_H
