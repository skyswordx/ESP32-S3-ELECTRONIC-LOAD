/**
 * @file RRTOS_publisher.h
 * @brief RRTOS话题发布者接口
 * @author Generated by AI Assistant
 * @date 2025-05-15
 * @details 提供RRTOS系统的话题发布功能
 */

#ifndef RRTOS_PUBLISHER_H
#define RRTOS_PUBLISHER_H

#include "RRTOS_common.h"
#include <string>

namespace RRTOS {

/**
 * @brief 话题发布者类
 */
class Publisher {
private:
    std::string topicName;    // 话题名称
    QueueHandle_t queueHandle; // 队列句柄
    size_t maxItemSize;       // 最大消息大小

public:
    /**
     * @brief 构造函数
     * @param topic 话题名称
     * @param handle 队列句柄
     * @param size 最大消息大小
     */
    Publisher(const std::string& topic, QueueHandle_t handle, size_t size)
        : topicName(topic), queueHandle(handle), maxItemSize(size) {}
    
    /**
     * @brief 获取话题名称
     * @return 话题名称
     */
    std::string getTopic() const {
        return topicName;
    }
      /**
     * @brief 发布数据
     * @tparam T 数据类型
     * @param msg 要发布的数据
     * @return 是否发布成功
     */
    template <typename T>
    bool publish(const T& msg) {
        // 检查消息大小是否超过队列允许的最大大小
        if (sizeof(T) > maxItemSize) {
            Serial.printf("警告: 消息大小(%u字节) 超过队列容量(%u字节)\n", 
                          sizeof(T), maxItemSize);
            return false;
        }
        
        // 从队尾发送消息，超时设置为0表示不阻塞
        BaseType_t result = xQueueSendToBack(queueHandle, &msg, 0);
        return (result == pdPASS);
    }
    
    /**
     * @brief advertise方法作为publish的别名
     * @tparam T 数据类型
     * @param value 要发布的数据
     * @return 是否发布成功
     */
    template <typename T>
    bool advertise(const T& value) {
        return publish(value);
    }
};

/**
 * @brief 创建发布者
 * @param topicName 话题名称
 * @param config 队列配置
 * @return 发布者对象
 */
Publisher createPublisher(const std::string& topicName, const QueueConfig& config = QueueConfig());

} // namespace RRTOS

#endif // RRTOS_PUBLISHER_H
