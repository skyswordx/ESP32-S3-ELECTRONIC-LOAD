Triwalt: 依据优化建议，制订逐步重构的总体计划与近期目标，存放在一个新建的日志中，并尝试逐步落实

GitHub Copilot: 我将为您创建一个重构计划日志，并帮助您制定近期目标和实施步骤。我将为您创建一个重构计划日志，并帮助您制定近期目标和实施步骤。通过对代码库的分析，我现在对项目结构有了更深入的了解，接下来我将帮助您创建一个重构计划日志。我已经为项目创建了重构计划的文档目录，接下来将在其中创建重构计划和阶段性目标。现在我已经深入分析了代码结构，可以看到您的项目是基于ESP32S3的多任务系统，主要涉及直流电子负载控制、GUI显示、传感器数据采集等功能。接下来，我将为您创建重构计划文档。
````
# ESP32S3-电子负载项目重构计划

## 一、项目分析总结

### 1. 现有架构问题

通过对项目分析，发现以下主要问题：

1. **任务管理混乱**：任务定义分散在main.cpp和our_tasks_config.cpp中，缺乏统一管理
2. **模块依赖不清晰**：模块间依赖关系隐含而非显式，不易理解和修改
3. **通信方式耦合**：任务间通信直接使用队列和全局变量，缺乏抽象层
4. **缺乏统一事件处理**：不同类型的事件处理方式不一致
5. **代码复用性低**：缺少合适的抽象和设计模式，难以复用功能模块

### 2. 现有代码结构

- **main.cpp**: 负责初始化和创建各种任务
- **our_tasks_config.cpp/h**: 包含所有任务的具体实现
- **lib/our_***：包含各功能模块的实现
  - `our_queue`: 队列通信相关
  - `our_button`: 按键处理
  - `our_encoder`: 编码器处理
  - `our_pid_controller`: PID控制器
  - `our_lvgl_interaction`: LVGL界面交互

### 3. 核心功能模块

1. **输入处理**：旋转编码器、按键
2. **硬件通信**：IIC设备(INA226、MCP4725)、ADC
3. **显示**：LVGL界面
4. **控制**：PID控制器
5. **保护**：过压保护

## 二、重构总体规划

### 1. 重构目标

1. **改善代码结构**：实现逻辑清晰、层次分明的代码结构
2. **降低模块耦合**：模块间通过明确的接口通信，减少依赖
3. **提高代码复用性**：应用合适的设计模式，提高复用性
4. **增强系统可维护性**：简化调试、日志记录和错误处理
5. **保持功能兼容**：确保重构后功能与当前一致

### 2. 架构设计方向

采用**事件驱动架构**结合**模块化设计**，新的架构将包括：

1. **硬件抽象层**：封装硬件访问操作
2. **设备驱动层**：实现具体设备的控制逻辑
3. **核心服务层**：提供事件总线、任务管理等核心服务
4. **业务逻辑层**：实现具体的业务功能
5. **界面层**：处理用户交互和显示

### 3. 拟采用的设计模式

1. **观察者模式**：用于事件通知系统
2. **工厂模式**：用于任务创建和管理
3. **策略模式**：用于不同控制策略（PID、直接DAC控制等）的切换
4. **命令模式**：封装界面交互和操作

## 三、阶段性计划

### 阶段一：基础结构重构（当前阶段）

#### 目标

1. 实现事件总线系统
2. 建立基本的任务管理器
3. 重构项目文件结构

#### 具体任务

1. **创建核心类**
   - 创建EventBus事件总线类
   - 创建TaskManager任务管理类
   - 创建Device基类和DeviceManager设备管理类

2. **重组项目文件结构**
   - 新建src/core目录放置核心功能
   - 新建src/drivers目录放置驱动层代码
   - 新建src/devices目录放置设备实现
   - 新建src/controllers目录放置控制器
   - 新建src/tasks目录放置任务实现
   - 新建src/ui目录放置UI相关代码

3. **构建统一的消息处理机制**
   - 定义事件类型枚举
   - 设计事件数据结构
   - 实现消息队列包装器

### 阶段二：功能模块重构

#### 目标

1. 重构设备驱动模块
2. 重构控制器模块
3. 重构任务功能模块

#### 具体任务

1. **重构设备模块**
   - 实现编码器设备类
   - 实现按键设备类
   - 实现INA226设备类
   - 实现MCP4725设备类

2. **重构控制器模块**
   - 实现CurrentController控制器
   - 实现PID和DirectDAC控制策略
   - 实现ProtectionController保护控制器

3. **重构任务模块**
   - 实现EncoderTask编码器任务
   - 实现ButtonTask按键任务
   - 实现DisplayTask显示任务
   - 实现其他功能任务

### 阶段三：整合与优化

#### 目标

1. 整合所有重构的模块
2. 优化性能和资源使用
3. 增强错误处理和日志记录

#### 具体任务

1. **整合功能模块**
   - 基于事件总线连接各模块
   - 调整各模块之间的交互

2. **系统优化**
   - 优化任务调度和优先级
   - 优化内存使用

3. **增强健壮性**
   - 添加错误处理机制
   - 实现日志记录系统

## 四、近期工作计划

### 第一周

1. **设计并实现事件总线**
   - 设计Event基类和EventListener接口
   - 实现EventBus核心类
   - 编写单元测试验证功能

2. **设计并实现任务管理器**
   - 设计TaskManager类
   - 实现任务创建和管理功能
   - 编写示例代码验证功能

3. **创建新的项目结构**
   - 建立目录结构
   - 迁移核心文件

### 第二周

1. **实现第一个重构模块：编码器处理**
   - 设计Encoder设备类
   - 实现EncoderTask任务类
   - 将现有编码器逻辑迁移到新结构

2. **实现控制策略接口**
   - 设计ControlStrategy接口
   - 实现PidControlStrategy和DirectDacControlStrategy

3. **编写示例代码验证功能**
   - 创建简单的测试程序验证事件总线
   - 验证任务管理器功能
   - 测试编码器模块重构效果

## 五、执行与监控

1. **版本控制**：使用Git分支管理重构过程
   - 创建`refactor/core`分支用于核心功能重构
   - 创建`refactor/tasks`分支用于任务重构
   - 创建`refactor/devices`分支用于设备重构

2. **测试计划**：
   - 为每个重构的模块编写单元测试
   - 设计集成测试验证模块间交互
   - 保持功能测试确保重构不破坏现有功能

3. **文档更新**：
   - 更新每个模块的文档
   - 编写新架构设计文档
   - 记录重构过程中的经验和教训
````


已进行更改。

接下来，我将创建基础事件系统模块的设计，作为重构第一阶段的首个具体实现：我已经创建了重构计划文档和核心模块的源文件目录。根据重构计划，现在我们将首先开始实现事件总线系统，这是重构的第一步。

让我们首先创建事件系统的基础类：
````
/**
 * @file Event.h
 * @brief 事件基类定义
 * @author Triwalt
 * @date 2025-05-06
 * @details 定义了系统中所有事件的基类和事件类型枚举
 */

#ifndef EVENT_H
#define EVENT_H

#include <Arduino.h>

/**
 * @brief 事件类型枚举
 */
enum class EventType {
    // 系统事件
    SYSTEM_STARTUP,
    SYSTEM_SHUTDOWN,
    
    // 按键事件
    BUTTON_PRESSED,
    BUTTON_RELEASED,
    BUTTON_LONG_PRESSED,
    
    // 编码器事件
    ENCODER_CHANGED,
    ENCODER_BUTTON_PRESSED,

    // 测量事件
    CURRENT_CHANGED,
    VOLTAGE_CHANGED,
    POWER_CHANGED,
    RESISTANCE_CHANGED,

    // 控制事件
    TARGET_CURRENT_CHANGED,
    
    // 警报事件
    OVER_VOLTAGE,
    OVER_CURRENT,
    OVER_POWER,
    
    // 测试事件
    LOAD_REGULATION_TEST,

    // UI事件
    UI_PAGE_CHANGED,
    
    // 未知事件
    UNKNOWN
};

/**
 * @brief 事件基类
 * @details 所有事件类型都应该继承此基类
 */
class Event {
public:
    /**
     * @brief 构造函数
     * @param type 事件类型
     */
    explicit Event(EventType type) : type_(type) {}
    
    /**
     * @brief 析构函数
     */
    virtual ~Event() = default;
    
    /**
     * @brief 获取事件类型
     * @return 事件类型
     */
    EventType getType() const { return type_; }
    
    /**
     * @brief 获取事件名称（用于调试）
     * @return 事件的字符串表示
     */
    virtual String toString() const {
        return "Event[type=" + String(static_cast<int>(type_)) + "]";
    }
    
protected:
    EventType type_; ///< 事件类型
};

#endif // EVENT_H
````


已进行更改。

接下来我将继续实现事件系统的核心组件——事件监听器接口和事件总线：
````
/**
 * @file EventListener.h
 * @brief 事件监听器接口定义
 * @author Triwalt
 * @date 2025-05-06
 * @details 定义了事件监听器接口，任何需要接收事件的类都应实现此接口
 */

#ifndef EVENT_LISTENER_H
#define EVENT_LISTENER_H

#include "Event.h"

/**
 * @brief 事件监听器接口
 * @details 任何需要接收事件的类都应实现此接口
 */
class EventListener {
public:
    /**
     * @brief 析构函数
     */
    virtual ~EventListener() = default;
    
    /**
     * @brief 接收事件的接口方法
     * @param event 接收到的事件对象
     * @return 如果事件被处理返回true，否则返回false
     */
    virtual bool onEvent(const Event& event) = 0;
    
    /**
     * @brief 获取监听器的标识符(用于调试)
     * @return 监听器的字符串标识符
     */
    virtual String getListenerId() const = 0;
};

#endif // EVENT_LISTENER_H
````


已进行更改。

现在让我们继续实现事件总线类，这是整个事件驱动框架的核心组件：
````
/**
 * @file EventBus.h
 * @brief 事件总线定义
 * @author Triwalt
 * @date 2025-05-06
 * @details 实现事件分发机制，连接事件发布者和订阅者
 */

#ifndef EVENT_BUS_H
#define EVENT_BUS_H

#include "Event.h"
#include "EventListener.h"
#include <vector>
#include <map>
#include <memory>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

/**
 * @brief 事件总线类
 * @details 实现了观察者模式，用于事件的发布和订阅
 */
class EventBus {
public:
    /**
     * @brief 获取EventBus单例
     * @return EventBus单例引用
     */
    static EventBus& getInstance();

    /**
     * @brief 发布事件
     * @param event 要发布的事件
     * @return 如果有监听器处理了该事件返回true，否则返回false
     */
    bool publish(const Event& event);

    /**
     * @brief 发布事件(智能指针版本)
     * @param event 要发布的事件的智能指针
     * @return 如果有监听器处理了该事件返回true，否则返回false
     */
    bool publish(const std::shared_ptr<Event>& event);
    
    /**
     * @brief 订阅特定类型的事件
     * @param type 要订阅的事件类型
     * @param listener 事件监听器指针
     */
    void subscribe(EventType type, EventListener* listener);
    
    /**
     * @brief 取消订阅特定类型的事件
     * @param type 要取消订阅的事件类型
     * @param listener 事件监听器指针
     */
    void unsubscribe(EventType type, EventListener* listener);
    
    /**
     * @brief 取消特定监听器的所有订阅
     * @param listener 要取消订阅的监听器
     */
    void unsubscribeAll(EventListener* listener);

private:
    /**
     * @brief 构造函数(私有)
     */
    EventBus();
    
    /**
     * @brief 析构函数(私有)
     */
    ~EventBus();

    /**
     * @brief 禁用拷贝构造函数
     */
    EventBus(const EventBus&) = delete;
    
    /**
     * @brief 禁用赋值操作符
     */
    EventBus& operator=(const EventBus&) = delete;

private:
    std::map<EventType, std::vector<EventListener*>> listeners_; ///< 事件类型到监听器列表的映射
    SemaphoreHandle_t mutex_; ///< 互斥锁，保护监听器列表的线程安全
};

#endif // EVENT_BUS_H
````


已进行更改。

接下来，我将实现事件总线类的具体功能。我已经创建了基础的头文件结构，现在让我们创建事件总线的实现文件：
````
/**
 * @file EventBus.cpp
 * @brief 事件总线实现
 * @author Triwalt
 * @date 2025-05-06
 * @details 事件总线的具体实现，包含事件分发、订阅和取消订阅功能
 */

#include "EventBus.h"
#include <Arduino.h>

EventBus& EventBus::getInstance() {
    static EventBus instance;
    return instance;
}

EventBus::EventBus() {
    // 创建互斥锁
    mutex_ = xSemaphoreCreateMutex();
    if (mutex_ == NULL) {
        Serial.println("Failed to create EventBus mutex!");
    }
}

EventBus::~EventBus() {
    // 释放互斥锁
    if (mutex_ != NULL) {
        vSemaphoreDelete(mutex_);
        mutex_ = NULL;
    }
}

bool EventBus::publish(const Event& event) {
    bool processed = false;
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) != pdTRUE) {
        Serial.println("Failed to take EventBus mutex!");
        return false;
    }
    
    // 获取事件类型对应的监听器列表
    EventType type = event.getType();
    auto it = listeners_.find(type);
    
    if (it != listeners_.end()) {
        // 创建一个临时副本，以便在通知过程中可以安全地修改原始列表
        std::vector<EventListener*> listenersCopy = it->second;
        xSemaphoreGive(mutex_); // 在遍历前释放互斥锁，允许在回调中注册或注销监听器
        
        // 通知所有监听器
        for (auto listener : listenersCopy) {
            if (listener) {
                if (listener->onEvent(event)) {
                    processed = true;
                }
            }
        }
    } else {
        xSemaphoreGive(mutex_); // 如果没有监听器，释放互斥锁
    }
    
    return processed;
}

bool EventBus::publish(const std::shared_ptr<Event>& event) {
    if (!event) {
        return false;
    }
    return publish(*event);
}

void EventBus::subscribe(EventType type, EventListener* listener) {
    if (!listener) {
        return;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) != pdTRUE) {
        Serial.println("Failed to take EventBus mutex!");
        return;
    }
    
    // 检查监听器是否已经订阅
    auto it = listeners_.find(type);
    if (it != listeners_.end()) {
        auto& listeners = it->second;
        bool alreadySubscribed = false;
        
        for (auto existingListener : listeners) {
            if (existingListener == listener) {
                alreadySubscribed = true;
                break;
            }
        }
        
        if (!alreadySubscribed) {
            listeners.push_back(listener);
            Serial.printf("Listener %s subscribed to event type %d\n", 
                          listener->getListenerId().c_str(), static_cast<int>(type));
        }
    } else {
        // 如果该事件类型没有监听器列表，创建一个新的
        listeners_[type] = {listener};
        Serial.printf("Listener %s subscribed to event type %d (new list)\n", 
                      listener->getListenerId().c_str(), static_cast<int>(type));
    }
    
    xSemaphoreGive(mutex_); // 释放互斥锁
}

void EventBus::unsubscribe(EventType type, EventListener* listener) {
    if (!listener) {
        return;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) != pdTRUE) {
        Serial.println("Failed to take EventBus mutex!");
        return;
    }
    
    // 查找该事件类型的监听器列表
    auto it = listeners_.find(type);
    if (it != listeners_.end()) {
        auto& listeners = it->second;
        
        // 移除指定的监听器
        listeners.erase(
            std::remove(listeners.begin(), listeners.end(), listener),
            listeners.end()
        );
        
        Serial.printf("Listener %s unsubscribed from event type %d\n", 
                     listener->getListenerId().c_str(), static_cast<int>(type));
        
        // 如果列表为空，删除该事件类型的条目
        if (listeners.empty()) {
            listeners_.erase(it);
        }
    }
    
    xSemaphoreGive(mutex_); // 释放互斥锁
}

void EventBus::unsubscribeAll(EventListener* listener) {
    if (!listener) {
        return;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) != pdTRUE) {
        Serial.println("Failed to take EventBus mutex!");
        return;
    }
    
    // 遍历所有事件类型
    for (auto it = listeners_.begin(); it != listeners_.end();) {
        auto& listeners = it->second;
        
        // 移除指定的监听器
        listeners.erase(
            std::remove(listeners.begin(), listeners.end(), listener),
            listeners.end()
        );
        
        // 如果列表为空，删除该事件类型的条目
        if (listeners.empty()) {
            it = listeners_.erase(it);
        } else {
            ++it;
        }
    }
    
    Serial.printf("Listener %s unsubscribed from all events\n", listener->getListenerId().c_str());
    
    xSemaphoreGive(mutex_); // 释放互斥锁
}
````


已进行更改。

现在我已经成功创建了基础的事件系统架构，包括：

1. `Event.h` - 定义了事件基类和事件类型枚举
2. `EventListener.h` - 定义了事件监听器接口
3. `EventBus.h`和`EventBus.cpp` - 实现了事件总线的核心功能

这套事件系统采用了观察者模式，是重构的第一步。现在我们需要实现任务管理器，它将负责创建和管理RTOS任务。

让我们继续实现这一重要组件：
````
/**
 * @file TaskManager.h
 * @brief 任务管理器定义
 * @author Triwalt
 * @date 2025-05-06
 * @details 管理FreeRTOS任务的创建、调度和销毁
 */

#ifndef TASK_MANAGER_H
#define TASK_MANAGER_H

#include <Arduino.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <map>
#include <string>
#include <vector>

/**
 * @brief 任务统计信息结构体
 */
struct TaskStats {
    String name;              ///< 任务名称
    UBaseType_t priority;     ///< 任务优先级
    uint32_t stackSize;       ///< 任务栈大小
    uint32_t stackHighWater;  ///< 任务栈高水位
    eTaskState taskState;     ///< 任务状态
    BaseType_t coreId;        ///< 任务运行的核心ID
};

/**
 * @brief 任务管理器类
 */
class TaskManager {
public:
    /**
     * @brief 获取TaskManager单例
     * @return TaskManager单例引用
     */
    static TaskManager& getInstance();
    
    /**
     * @brief 创建并启动一个任务
     * @param name 任务名称
     * @param function 任务函数指针
     * @param params 任务参数
     * @param stackSize 任务栈大小
     * @param priority 任务优先级
     * @param coreId 任务运行的核心ID（0或1）
     * @return 任务句柄，如果创建失败则返回NULL
     */
    TaskHandle_t startTask(
        const String& name,
        TaskFunction_t function,
        void* params,
        uint32_t stackSize = 1024 * 4,
        UBaseType_t priority = 1,
        BaseType_t coreId = tskNO_AFFINITY
    );
    
    /**
     * @brief 停止并删除一个任务
     * @param handle 任务句柄
     * @return 如果成功删除返回true，否则返回false
     */
    bool stopTask(TaskHandle_t handle);
    
    /**
     * @brief 暂停一个任务
     * @param handle 任务句柄
     * @return 如果成功暂停返回true，否则返回false
     */
    bool suspendTask(TaskHandle_t handle);
    
    /**
     * @brief 恢复一个任务
     * @param handle 任务句柄
     * @return 如果成功恢复返回true，否则返回false
     */
    bool resumeTask(TaskHandle_t handle);
    
    /**
     * @brief 根据任务句柄获取任务统计信息
     * @param handle 任务句柄
     * @return 任务统计信息
     */
    TaskStats getTaskStats(TaskHandle_t handle);
    
    /**
     * @brief 根据任务名称获取任务句柄
     * @param name 任务名称
     * @return 任务句柄，如果未找到则返回NULL
     */
    TaskHandle_t getTaskHandleByName(const String& name);
    
    /**
     * @brief 获取所有任务的统计信息
     * @return 包含所有任务统计信息的vector
     */
    std::vector<TaskStats> getAllTaskStats();
    
private:
    /**
     * @brief 构造函数(私有)
     */
    TaskManager();
    
    /**
     * @brief 析构函数(私有)
     */
    ~TaskManager();
    
    /**
     * @brief 禁用拷贝构造函数
     */
    TaskManager(const TaskManager&) = delete;
    
    /**
     * @brief 禁用赋值操作符
     */
    TaskManager& operator=(const TaskManager&) = delete;
    
    /**
     * @brief 从任务管理器中移除一个任务记录
     * @param handle 任务句柄
     */
    void removeTaskRecord(TaskHandle_t handle);

private:
    std::map<TaskHandle_t, String> tasks_; ///< 任务句柄到名称的映射
    SemaphoreHandle_t mutex_;             ///< 互斥锁，保护任务列表的线程安全
};

#endif // TASK_MANAGER_H
````


已进行更改。

现在我将继续实现任务管理器的具体功能，通过编写TaskManager.cpp文件：
````
/**
 * @file TaskManager.cpp
 * @brief 任务管理器实现
 * @author Triwalt
 * @date 2025-05-06
 * @details 实现管理FreeRTOS任务的创建、调度和销毁的具体功能
 */

#include "TaskManager.h"

TaskManager& TaskManager::getInstance() {
    static TaskManager instance;
    return instance;
}

TaskManager::TaskManager() {
    // 创建互斥锁
    mutex_ = xSemaphoreCreateMutex();
    if (mutex_ == NULL) {
        Serial.println("Failed to create TaskManager mutex!");
    }
}

TaskManager::~TaskManager() {
    // 停止所有任务
    std::vector<TaskHandle_t> taskHandles;
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        for (const auto& pair : tasks_) {
            taskHandles.push_back(pair.first);
        }
        xSemaphoreGive(mutex_);
    }
    
    // 停止所有任务
    for (const auto& handle : taskHandles) {
        stopTask(handle);
    }
    
    // 释放互斥锁
    if (mutex_ != NULL) {
        vSemaphoreDelete(mutex_);
        mutex_ = NULL;
    }
}

TaskHandle_t TaskManager::startTask(
    const String& name,
    TaskFunction_t function,
    void* params,
    uint32_t stackSize,
    UBaseType_t priority,
    BaseType_t coreId
) {
    TaskHandle_t handle = NULL;
    
    // 创建任务
    BaseType_t result = xTaskCreatePinnedToCore(
        function,
        name.c_str(),
        stackSize,
        params,
        priority,
        &handle,
        coreId
    );
    
    if (result != pdPASS || handle == NULL) {
        Serial.printf("Failed to create task: %s\n", name.c_str());
        return NULL;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        tasks_[handle] = name;
        Serial.printf("Task created: %s (handle=%p)\n", name.c_str(), handle);
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
        vTaskDelete(handle);
        return NULL;
    }
    
    return handle;
}

bool TaskManager::stopTask(TaskHandle_t handle) {
    if (handle == NULL) {
        return false;
    }
    
    String taskName = "";
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        auto it = tasks_.find(handle);
        if (it != tasks_.end()) {
            taskName = it->second;
            tasks_.erase(it);
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
        return false;
    }
    
    if (!taskName.isEmpty()) {
        Serial.printf("Stopping task: %s (handle=%p)\n", taskName.c_str(), handle);
        vTaskDelete(handle);
        return true;
    }
    
    return false;
}

bool TaskManager::suspendTask(TaskHandle_t handle) {
    if (handle == NULL) {
        return false;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        auto it = tasks_.find(handle);
        if (it != tasks_.end()) {
            xSemaphoreGive(mutex_);
            Serial.printf("Suspending task: %s (handle=%p)\n", it->second.c_str(), handle);
            vTaskSuspend(handle);
            return true;
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
    }
    
    return false;
}

bool TaskManager::resumeTask(TaskHandle_t handle) {
    if (handle == NULL) {
        return false;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        auto it = tasks_.find(handle);
        if (it != tasks_.end()) {
            xSemaphoreGive(mutex_);
            Serial.printf("Resuming task: %s (handle=%p)\n", it->second.c_str(), handle);
            vTaskResume(handle);
            return true;
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
    }
    
    return false;
}

TaskStats TaskManager::getTaskStats(TaskHandle_t handle) {
    TaskStats stats;
    stats.name = "";
    
    if (handle == NULL) {
        return stats;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        auto it = tasks_.find(handle);
        if (it != tasks_.end()) {
            stats.name = it->second;
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
        return stats;
    }
    
    // 获取任务信息
    if (!stats.name.isEmpty()) {
        TaskStatus_t taskDetails;
        vTaskGetInfo(handle, &taskDetails, pdTRUE, eInvalid);
        
        stats.priority = taskDetails.uxCurrentPriority;
        stats.taskState = taskDetails.eCurrentState;
        stats.stackHighWater = taskDetails.usStackHighWaterMark;
        stats.coreId = taskDetails.xCoreID;
        
        // 获取任务栈大小（FreeRTOS API未提供直接获取方式，这里使用默认值）
        stats.stackSize = 1024 * 4; // 默认值
    }
    
    return stats;
}

TaskHandle_t TaskManager::getTaskHandleByName(const String& name) {
    TaskHandle_t handle = NULL;
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        for (const auto& pair : tasks_) {
            if (pair.second == name) {
                handle = pair.first;
                break;
            }
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
    }
    
    return handle;
}

std::vector<TaskStats> TaskManager::getAllTaskStats() {
    std::vector<TaskStats> allStats;
    std::vector<TaskHandle_t> taskHandles;
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        for (const auto& pair : tasks_) {
            taskHandles.push_back(pair.first);
        }
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
        return allStats;
    }
    
    // 获取每个任务的统计信息
    for (const auto& handle : taskHandles) {
        TaskStats stats = getTaskStats(handle);
        if (!stats.name.isEmpty()) {
            allStats.push_back(stats);
        }
    }
    
    return allStats;
}

void TaskManager::removeTaskRecord(TaskHandle_t handle) {
    if (handle == NULL) {
        return;
    }
    
    // 尝试获取互斥锁
    if (xSemaphoreTake(mutex_, portMAX_DELAY) == pdTRUE) {
        tasks_.erase(handle);
        xSemaphoreGive(mutex_);
    } else {
        Serial.println("Failed to take TaskManager mutex!");
    }
}
````


已进行更改。

现在我已经完成了重构的第一步，创建了事件系统和任务管理器的核心组件。这些组件是整个重构的基础，它们将为以后的功能模块提供核心服务。我们已经成功实现了：

1. **事件系统**：
   - `Event.h`：定义了事件基类和事件类型枚举
   - `EventListener.h`：定义了事件监听器接口
   - `EventBus.h/cpp`：实现了事件分发机制

2. **任务管理器**：
   - `TaskManager.h/cpp`：实现了FreeRTOS任务的创建、管理和监控

接下来，我需要创建一个简单的示例，验证这些新组件的工作。我将为您创建一个编码器事件类，作为如何扩展事件系统的示例：已成功创建了设备目录。现在让我为您实现编码器事件类，作为如何使用和扩展事件系统的示例：
````
/**
 * @file EncoderEvent.h
 * @brief 编码器事件定义
 * @author Triwalt
 * @date 2025-05-06
 * @details 定义了与编码器相关的事件类型
 */

#ifndef ENCODER_EVENT_H
#define ENCODER_EVENT_H

#include "../core/Event.h"

/**
 * @brief 编码器值改变事件
 */
class EncoderValueChangedEvent : public Event {
public:
    /**
     * @brief 构造函数
     * @param value 新的编码器值
     */
    explicit EncoderValueChangedEvent(double value)
        : Event(EventType::ENCODER_CHANGED), value_(value) {}
    
    /**
     * @brief 获取编码器值
     * @return 编码器值
     */
    double getValue() const { return value_; }
    
    /**
     * @brief 获取事件名称（用于调试）
     * @return 事件的字符串表示
     */
    String toString() const override {
        return "EncoderValueChangedEvent[value=" + String(value_) + "]";
    }
    
private:
    double value_; ///< 编码器值
};

/**
 * @brief 编码器按键事件
 */
class EncoderButtonEvent : public Event {
public:
    /**
     * @brief 构造函数
     * @param pressed 按键是否被按下
     */
    explicit EncoderButtonEvent(bool pressed)
        : Event(pressed ? EventType::BUTTON_PRESSED : EventType::BUTTON_RELEASED),
          pressed_(pressed) {}
    
    /**
     * @brief 判断按键是否被按下
     * @return 如果按下返回true，否则返回false
     */
    bool isPressed() const { return pressed_; }
    
    /**
     * @brief 获取事件名称（用于调试）
     * @return 事件的字符串表示
     */
    String toString() const override {
        return "EncoderButtonEvent[pressed=" + String(pressed_ ? "true" : "false") + "]";
    }
    
private:
    bool pressed_; ///< 按键是否被按下
};

#endif // ENCODER_EVENT_H
````


已进行更改。

我已经成功创建了重构计划和首批核心组件，让我们总结一下目前的进展：

1. 创建了详细的**重构计划文档**，包括分析总结、总体规划和分阶段实施计划。

2. 实现了**事件系统**的核心组件：
   - `Event.h` - 定义了事件基类和事件类型枚举
   - `EventListener.h` - 定义了事件监听器接口
   - `EventBus.h/cpp` - 实现了事件总线，负责事件的分发

3. 实现了**任务管理器**：
   - `TaskManager.h/cpp` - 封装了FreeRTOS任务管理功能，便于创建和监控任务

4. 创建了示例事件类：
   - `EncoderEvent.h` - 包含编码器值变化和按键事件类的定义

这些是重构的第一阶段的核心组件，它们将作为新架构的基础。已经创建的组件采用了观察者模式和单例模式，为后续的模块化设计提供了良好的基础。

接下来需要进行的工作包括：

1. 实现消息队列的封装类，使队列通信更加简便和安全
2. 设计设备基类和设备管理器
3. 实现编码器设备类，作为第一个完整重构的设备模块
4. 重构PID控制器，应用策略模式

这些工作将在项目的新目录结构中进行，我已经创建了基础的目录架构来支持这种模块化设计。

希望这个重构计划和已经实现的组件能够满足您的期望。接下来可以继续实现设备管理部分，或者按照重构计划中的优先级进行其他任务的实现。您对下一步有什么特别的需求或偏好吗？