## RRTOS重构

请你在FreeRTOS的接口上模仿 ROS 的接口，使用RRTOS作为命名空间，进行接口创建

注意到，我们已经使用了FreeRTOS，其中的任务task就类似于ROS中的node节点
而我们自己使用ROS也是手动创建node节点cpp文件和hpp文件，所以不需要封装接口去创建task

请你参考现有的一些现有代码的重复化操作，比如我们自己手动建立队列、信号量、然后手动在收发两方的任务创建接受队列的代码结构

然后在src/refactor目录下新建问文件，进行重构，主要注意去模仿ROS话题通信和服务通信的接口，进行重构以便实现两种通信方式
1. 基于FreeRTOS的队列、信号量、事件组等机制，实现类似ROS中话题通信可以自定义添加任意数量的发布者和订阅者，进行可以指定任意话题类型的广播通信，每一种通信使用的消息类型可以在一个头文件定义
	1. 具体而言我们可以在一个普通的FreeRTOS任务中，只通过包含RRTOS_message、RRTOS_publisher和RRTOS_subscriber这3个头文件，就可以实现上述的依赖要求，方便移植
	2. 不过多添加自己的封装接口，把发布者、订阅者和消息接口只保留在上述文件中。方便项目拓展和移植
	3. 接口尽量模仿ROS精简的风格，比如使用`RRTOS::Publisher pub`即可创建发布者对象(推荐在创建时调用一个模板函数，塞入话题名称标志即可实现特定的发布者），然后在循环中调用发布者对象的函数以发送数据
	4. 重点：要发送消息的数据类型是通过advertise函数的模板实现的，这个数据类型可以是默认的数据类型，比如int、double、也可以是用户自己定义的结构体，这个部分让用户自己定义即可，不需要你自己封装，尽量保持精简的风格（如果用户指定的queue_config中的队列元素大小小于这个类型，取最大的那个以保持兼容）
	
例子
```
include ...

taskFunction(){
	RRTOS::pub("topic_name", queue_config);

	while(true){
	    pub.advertise<data_type>();
	
	}
}
```


2. 基于FreeRTOS的二值信号量与阻塞机制，实现类似ROS中的服务阻塞式通信
	1. 具体而言我们可以在一个普通的FreeRTOS任务中，只通过包含RRTOS_service、RRTOS_server和RRTOS_client这3个头文件，就可以实现上述的依赖要求，方便移植
	2. 接口要求同话题通信，尽量模仿ROS精简的风格

你的话题通信和服务通信部分，在有关于消息和服务类型那里还不够精简，我不需要你设置一个专门的类去代表消息或者服务类型，我们要用什么类型我们自己会搞，不要自己帮我们封装
```
template <typename T>

struct Message : public MessageHeader {

    T data;  // 消息数据

  

    // 默认构造函数

    Message() : MessageHeader(), data() {}

    // 带数据的构造函数

    explicit Message(const T& value) : MessageHeader(), data(value) {}

};
```

根本没有存在的必要，服务那边也是，都删掉

类似的接口
```
template <typename T>

    bool publish(const Message<T>& msg) {
```

改成
```
template <typename T>

    bool publish(T msg) {
```

## 2 细化

帮我重命名一下各个文件，和命名空间，要求把 RRTOS 前缀去掉，而命名空间关键字换成 OUR，然后帮我删去旧有的RRTOS相关文件

再帮我参考我们 `our_queue` 文件接口，修改我们的发布者和订阅者的消息接口，消息接口以利用 `our_queue` 文件为主进行修改

遵循下面的接口设计规范

发布者对象在建立时会有检查地创建一个队列


请你按照我的需求，【整理和规范化】这个 api 说明文档和学习手册
- 要求在与 claude 开始进行新聊天时，在附件包含文档，即可达到可以依据文档中的规范与格式进行编写代码的准确和无误【特别是要避免像经常使用一些虚空搓出来的方法】
- 在前半部分，按照人类学习者由浅入深的学习方式，先从简单的例子开始，然后逐步深入到复杂的例子，降低学习曲线陡峭程度，先在整体上把握住大方向
- 在后半部分，详细的按照功能模块介绍对应是哪些个文件实现的，一些接口函数的具体实现细节解析
- 在每一个进行介绍的部分，都要有该部分的使用示例和修改维护规范什么的，要有具体的使用场景和例子对 api 如何使用进行说明