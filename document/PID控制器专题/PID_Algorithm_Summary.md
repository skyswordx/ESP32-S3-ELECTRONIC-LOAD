# PID控制器算法流程（学术论文图表版本）

## 简化版伪代码（适合论文图表）

```
算法1：带防微分冲击和智能积分限幅的PID控制器

输入：r(k), y(k), Kp, Ki, Kd
输出：u(k)

1. 计算误差：e(k) = r(k) - y(k)

2. 计算PID各项：
   P = Kp × e(k)
   I = I + Ki × e(k)  
   D = Kd × (y(k-1) - y(k))    // 防微分冲击

3. 计算输出：u(k) = u(k-1) + P + I + D

4. 智能积分限幅：
   IF u(k) > umax THEN
       I = I - (u(k) - umax)
       u(k) = umax
   ELSE IF u(k) < umin THEN  
       I = I - (u(k) - umin)
       u(k) = umin

5. 更新历史值：y(k-1) = y(k), u(k-1) = u(k)

6. 返回：u(k)
```

## 数学表达式（论文格式）

### 基本PID方程
```
u(k) = u(k-1) + Kp·e(k) + Ki·e(k) + Kd·[y(k-1) - y(k)]
```

### 防微分冲击
```
传统：D = Kd·[e(k) - e(k-1)]
改进：D = Kd·[y(k-1) - y(k)]
```

### 智能积分限幅
```
当 u(k) > umax 时：I ← I - [u(k) - umax]
当 u(k) < umin 时：I ← I - [u(k) - umin]
```

## FreeRTOS中断管理范式

```
算法：按键中断处理系统

1. 系统初始化：
   创建消息队列和信号量
   FOR 每个按键 DO 安装GPIO中断服务程序

2. 最小化ISR：
   接收中断 → 发送引脚号到队列 → 释放信号量 → 返回

3. 复杂任务处理：
   等待信号量 → 从队列读取 → 消抖 → 时长测量 → 功能映射
```

### RTOS设计优势
- **实时性保证**：ISR执行时间 < 10μs
- **任务隔离**：复杂逻辑在任务上下文处理
- **资源安全**：队列+信号量保证线程安全
- **低功耗**：任务可阻塞，CPU可休眠

## 函数式编程接口设计

```
算法：硬件接口绑定
1. 定义传感器读取函数：
   read_sensor() → return INA226_getCurrent_mA()

2. 定义输出转换函数：
   convert_output(value) → MCP4725_setVoltage(value)

3. 绑定到控制器：
   controller.read_sensor = read_sensor
   controller.convert_output = convert_output
```

## 关键特性对比表

| 特性 | 传统PID | 本算法 | 优势 |
|------|---------|--------|------|
| 微分项计算 | e(k)-e(k-1) | y(k-1)-y(k) | 避免设定值跳变冲击 |
| 积分限幅 | 直接截断 | 动态调整 | 快速脱离饱和状态 |
| 输出结构 | 位置式 | 增量式 | 数值稳定性好 |
| 抗干扰性 | 一般 | 增强 | 适应性强 |

## 实验验证场景

基于ESP32-S3电子负载系统的实验验证：
- **应用场景**：恒流负载控制
- **控制对象**：电流控制环路  
- **性能指标**：
  - 设定值跟踪精度：±1%
  - 设定值阶跃响应时间：<100ms
  - 超调量：<5%
  - 稳态误差：<0.5%

## 论文引用格式

本算法适用于需要快速响应和高精度控制的应用场景，特别是在电力电子、电机控制和精密仪器等领域具有显著优势。
