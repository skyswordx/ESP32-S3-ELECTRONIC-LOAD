
# 恒流小子设计报告
## 软件设计

本电子负载项目的软件系统基于 **ESP32-S3** 微控制器构建，采用 **FreeRTOS** 实时操作系统作为核心调度框架，旨在实现精确的电流控制、友好的用户交互以及稳定可靠的系统运行。整体软件设计遵循模块化思想和分层架构理念，从底层硬件抽象到上层应用逻辑，构建了一套完整的嵌入式控制系统。

### 一、系统整体架构与任务组织

#### RTOS任务体系构建

基于FreeRTOS实时内核，本系统构建了包含8个核心任务的多任务体系，每个任务承担特定的功能职责。系统采用ESP32-S3双核处理器的异构计算能力，实现了合理的负载分配策略：**Core 0**专门负责用户界面渲染与人机交互处理，包括LVGL图形任务调度（`lvgl_task`）、GUI数据更新任务（`update_gui_task`）以及系统启动管理任务（`startup_task`）；**Core 1**则承担实时性要求较高的控制与数据处理任务，包括电流控制任务（`set_current_task`）、传感器数据采集任务（`get_ina226_data_task`）、编码器输入处理任务（`get_encoder1_data_task`）、过压保护任务（`over_voltage_protection_task`）以及按键中断处理任务（`button_handler_task`）。

这种核心分配策略充分利用了双核架构的并行处理能力，确保用户界面的流畅响应不会影响底层控制回路的实时性，同时避免了控制算法的计算负载对用户交互体验产生干扰。通过精心设计的任务分工与核心绑定，系统实现了高效的资源利用和优异的实时性能。

#### 任务优先级设计考量

系统任务优先级分配遵循"安全第一、控制次之、交互为重、显示最低"的设计原则，同时充分考虑了FreeRTOS抢占式调度器的特性和阻塞-非阻塞任务的差异化设计理念。

**最高优先级（5级）**，赋予按键处理任务（`button_handler_task`），该任务采用阻塞式设计，通过 `xSemaphoreTake(button_xBinarySemaphore, portMAX_DELAY)` 进入阻塞状态，仅在中断触发时被唤醒。这种高优先级阻塞式设计确保了用户紧急操作的立即响应能力，同时在无按键事件时不会消耗任何CPU资源，不会干扰其他任务的实时性。

**次高优先级（4级）**，分配给过压保护任务（`over_voltage_protection_task`）和负载测试任务（`get_load_changing_rate_task`），均采用阻塞等待机制。过压保护任务通过 `xSemaphoreTake(over_voltage_protection_xBinarySemaphore, portMAX_DELAY)` 保持阻塞，仅在数据采集任务检测到过压异常时通过 `xSemaphoreGive()` 瞬间唤醒执行保护动作；负载测试任务同样通过 `xSemaphoreTake(load_testing_xBinarySemaphore, portMAX_DELAY)` 阻塞等待测试触发信号。这些高优先级阻塞任务在正常工作状态下不占用CPU时间片，确保了安全保护功能的最高响应优先级，同时避免对系统实时性造成负面影响。

**中等优先级（3级）**，设置给电流控制任务（`set_current_task`）和LVGL核心调度任务（`lvgl_task`）。电流控制任务采用固定10ms周期的非阻塞循环设计（`vTaskDelay(10 / portTICK_PERIOD_MS)`），确保PID控制回路的时间确定性；LVGL任务以20ms周期执行图形渲染（`lv_task_handler()`），维持用户界面的流畅响应。这两个任务的周期性执行特性确保了控制算法的稳定性和界面交互的连续性。

**较低优先级（2级）**，分配给各类数据采集任务，包括传感器读取任务（`get_ina226_data_task`）、编码器处理任务（`get_encoder1_data_task`）和ADC采集任务（`ADC1_read_task`）。这些任务均采用非阻塞周期性设计：INA226传感器任务以200ms周期采集电压、电流、功率数据；编码器任务以200ms周期读取用户设定值；ADC任务以1000ms周期进行电压采样。**这种低优先级的周期性设计符合RTOS时间片轮转调度的核心思想**——这些高优先级任务虽然高优先级，但在没用触发前保持阻塞，是不会干扰到系统采样的实时性的，通过定时器中断确保低优先级任务在高优先级任务空闲时能够获得确定性的执行机会，从而保证传感器数据的实时采样和系统状态的持续监控。

**最低优先级（1级）**，则留给GUI更新任务（`update_gui_task`）和启动管理任务（`startup_task`）等非关键任务。GUI更新任务通过消息队列阻塞等待（`xQueueReceive(LVGL_queue, &queue_element, portMAX_DELAY)`）界面数据更新请求，在无更新需求时不消耗CPU资源；启动任务在系统初始化完成后即删除自身（`vTaskDelete(NULL)`），体现了临时性管理任务的设计理念。

这种层次化的优先级设计充分体现了现代RTOS任务调度的设计精髓：**高优先级任务采用事件驱动的阻塞式设计，确保关键功能的即时响应；低优先级任务采用周期性非阻塞设计，在高优先级任务阻塞时通过定时器中断保证基础功能的持续执行**。这种阻塞-非阻塞的混合调度策略不仅保证了安全保护和用户交互的最高优先级，同时确保了数据采集和控制算法的实时性要求，实现了系统资源的最优化配置和卓越的实时性能。

### 二、任务间通信机制设计

#### 信号量与互斥量应用

系统采用了完整的FreeRTOS同步机制来协调任务间的协作关系。**二值信号量**广泛应用于事件驱动的任务唤醒场景，包括按键中断信号量（`button_xBinarySemaphore`）、过压保护信号量（`over_voltage_protection_xBinarySemaphore`）、系统启动信号量（`startup_xBinarySemaphore`）以及各类测试功能信号量。这些信号量实现了高效的事件响应机制，避免了轮询带来的CPU资源浪费。

二值信号量在本质上是一个只能取值 0 或 1 的计数信号量，它在系统中主要承担两个核心功能：**任务同步**和**事件通知**。与传统的轮询机制相比，二值信号量提供了一种"Give生产-Take消费"模式的异步通信机制，其中信号量的"Give"操作对应事件的产生，"Take"操作对应事件的消费

持续 take 信号量的任务的会由于信号量从 1 变为 0 而保持阻塞，进入阻塞之后就从调度器的就绪列表中被移除，需要其他进行 give 操作的任务作为触发源（如 GPIO、ADC 等硬件中断、传感器采样数据超过程序中设定的阈值等）才能从阻塞状态被唤醒。这种设计使得等待事件的任务完全"休眠"，直到事件发生才被唤醒，实现了真正的零 CPU 开销等待。


典型的例子就是过压保护任务的信号量阻塞控制机制：过压保护任务在正常状态下通过 `xSemaphoreTake(over_voltage_protection_xBinarySemaphore, portMAX_DELAY)` 进入阻塞状态，不占用任何CPU资源；当数据采集任务检测到电压异常时，立即通过 `xSemaphoreGive()` 释放信号量，瞬间唤醒保护任务执行紧急关断操作。这种机制使得等待事件的任务完全"休眠"，直到事件发生才被唤醒，实现了真正的任务完全休眠，又可以保证微秒级的保护响应时间，大大提升了系统的安全性能

另外的例子是"中断 Give，任务 Take"的经典协作模式，在本系统中用于按键处理与消抖，这种模式的核心优势在于：**中断处理最小化，复杂逻辑任务化**。中断服务程序仅完成必要的硬件响应和信号量释放，所有复杂的业务逻辑都在任务上下文中处理，避免了中断嵌套和系统响应性能的影响

互斥量（Mutex）本质上是一种特殊的二值信号量，但与普通二值信号量的关键区别在于**在一个任务的开始先 take，在同一个任务结束后才 give 的，从而保证该任务不会被阻塞，保证线程安全**。换言之，互斥量必须由获取它的任务来释放，这种特性确保了资源访问的排他性和安全

本系统中**互斥量**主要用于保护LVGL图形库的线程安全访问。由于 LVGL 本身是**非线程安全**的库，多个任务同时调用 LVGL API 会导致数据竞争、界面显示异常甚至系统崩溃，系统通过 `gui_xMutex` 互斥量确保同一时刻只有一个任务能够访问LVGL接口，有效避免了多任务并发访问导致的界面显示异常和系统崩溃问题。

总结起来，在本系统的设计中，二值信号量主要用于**事件通知**和**任务同步**，特别是中断与任务间的通信（When to do）；而互斥量专门用于**资源保护**，确保共享资源（如 LVGL 接口）的互斥访问（How to do safely）。这种明确的职责分工体现了 RTOS 设计的最佳实践，通过这种分层的同步机制设计，系统实现了高效的任务协作和可靠的资源保护，为复杂的多任务应用提供了坚实的并发控制基础

#### 消息队列通信架构

系统构建了基于模板类的消息队列通信架构，通过`QueueElement_t<T>`模板类实现了类型安全的数据传输。主要包括两个核心消息队列：`LVGL_queue`负责各功能模块向GUI系统传递显示数据，队列容量设置为1000个元素，足以应对高频数据更新需求；`button_queue`专门处理按键中断产生的GPIO引脚信息，实现中断服务程序与按键处理任务的解耦。

消息队列的设计采用了统一的数据结构，包含任务标识符（`task_id_t`）、数据内容（`T data`）和数据描述符（`data_description_t`）三个核心字段。这种设计使得不同类型的数据能够在同一队列中传输，通过任务ID和数据描述符实现精确的数据路由和处理。例如，INA226传感器任务可以向队列发送电压、电流、功率、电阻四种不同类型的测量数据，GUI更新任务根据数据描述符将数据更新到对应的界面控件。

### 三、核心功能模块实现

#### 电流控制系统的PID算法实现

电流控制系统采用了基于模板类设计的增量式PID控制器，该控制器通过`PID_controller_t<double>`模板类实现，具备良好的类型安全性和代码复用性。控制器的核心算法运行在`set_current_task`任务中，以10ms的固定周期执行PID运算，确保了控制回路的确定性时间响应。

增量式PID算法的核心在于计算控制量的增量而非绝对值，其算法表达式为：`Δu(k) = Kp×[e(k)-e(k-1)] + Ki×e(k) + Kd×[e(k)-2×e(k-1)+e(k-2)]`。系统实现中特别采用了"防微分冲击"设计，微分项通过测量值变化`Kd×(last_measure - measure)`而非误差变化计算，有效避免了给定值突变时产生的微分冲击现象。

在积分抗饱和处理上，系统实现了智能动态限幅策略。当控制输出超出限制范围时，系统会相应调整积分项的累积值，防止积分饱和对控制性能的影响。具体实现为根据设定电流值动态确定输出上限 `output_finall = min(3 * target_voltage, OUTPUT_MAX)`，当输出超限时通过 `i_term -= (controller_output - output_final)` 调整积分项，确保控制器在约束条件下的最优性能。

PID 控制器还采用了函数式编程的设计模式，通过Lambda表达式绑定传感器读取和输出转换函数：`current_ctrl.read_sensor = []() -> double { return INA226_device.getCurrent_mA_plus(); }` 和 `current_ctrl.convert_output = [](double output) -> double { MCP4725_device.setVoltage(output); return output; }`。这种设计实现了控制算法与硬件接口的完全解耦，提高了代码的可维护性和可测试性。

#### 按键处理的RTOS中断管理范式

按键处理系统严格遵循FreeRTOS中断管理的最佳实践，采用"中断服务程序最小化，任务处理复杂化"的设计范式。系统通过`gpio_install_isr_service(0)`统一安装GPIO中断服务，然后为每个按键分别绑定特定的中断处理函数，如`gpio_isr_handler_add(button1.pin, button1_press_ISR, (void *)&button1.pin)`。

中断服务程序设计极其精简，仅执行两个关键操作：向按键消息队列发送被触发的GPIO引脚号信息`xQueueSendFromISR(button_queue, &pin_number, &xHigherPriorityTaskWoken)`，以及释放按键处理信号量`xSemaphoreGiveFromISR(button_xBinarySemaphore, &xHigherPriorityTaskWoken)`。中断服务程序中的所有FreeRTOS API调用均使用FromISR版本，确保中断上下文的安全性。

复杂的按键逻辑处理完全在`button_handler_task`任务中实现，该任务通过信号量阻塞等待中断唤醒，被唤醒后从消息队列读取GPIO信息，然后执行完整的按键状态检测，包括消抖处理、长短按识别、功能映射等。系统通过RTOS时间片轮询实现精确的按键时长测量，长按阈值设置为1000ms，通过`while(gpio_get_level(GPIO_PIN) == LOW)`循环监测按键释放，实现了可靠的按键状态识别。

#### 数据采集与传感器接口设计

数据采集系统以INA226高精度电流/电压传感器为核心，通过I2C总线实现数据通信。`get_ina226_data_task`任务负责周期性读取传感器数据，包括电流值（`getCurrent_mA_plus()`）、电压值（`getBusVoltage_plus()`）以及计算功率值和电阻值。系统对INA226进行了精细的配置优化，设置分流电阻值为20mΩ，电流转换时间和电压转换时间均设置为8.3ms，平衡了测量精度和响应速度的需求。

数据采集任务集成了实时过压检测功能，每次数据读取后立即判断电压是否超过预设阈值`WARNING_VOLTAGE`。一旦检测到过压状态，任务立即通过`xSemaphoreGive(over_voltage_protection_xBinarySemaphore)`触发保护任务，实现了数据采集与安全保护的紧密耦合。同时，任务通过消息队列机制将多路测量数据同步发送到GUI系统，每种数据类型通过不同的`data_description_t`标识符进行区分。

编码器输入处理同样采用任务化设计，`get_encoder1_data_task`任务管理ESP32Encoder库的接口调用，支持四倍频（QUAD）和单倍频（SINGLE）两种工作模式。任务通过`read_count_accum_clear()`方法读取累积计数值，经过范围限制（50-1800mA）后直接设置为PID控制器的目标值，实现了用户输入到控制设定的直接映射。

### 四、用户界面系统架构

#### LVGL图形系统的多任务协作

用户界面系统基于LVGL 8.3.10图形库构建，通过TFT_eSPI驱动库实现与SPI显示屏的硬件接口。系统采用双任务协作的界面架构：`lvgl_task`专门负责LVGL核心调度器的执行，以20ms周期调用`lv_task_handler()`驱动图形渲染引擎；`update_gui_task`则专门处理界面数据更新，通过消息队列接收各功能模块的数据并更新到对应的GUI控件。

这种分离式设计的核心优势在于将图形渲染与数据处理解耦，避免了数据更新操作对图形渲染周期性的干扰。LVGL核心任务保持稳定的20ms渲染周期，确保界面动画和用户交互的流畅性；而数据更新任务则可以根据数据到达的实际情况灵活调度，实现了系统资源的优化利用。

#### 线程安全的GUI访问机制

由于LVGL图形库本身不具备线程安全特性，系统通过互斥量机制实现了安全的多任务GUI访问。所有涉及LVGL接口调用的代码段均通过`xSemaphoreTake(gui_xMutex, portMAX_DELAY)`获取访问权限，操作完成后通过`xSemaphoreGive(gui_xMutex)`释放锁资源。这种设计确保了LVGL内部数据结构的一致性，有效避免了多任务并发访问导致的界面异常和系统崩溃。

特别是在过压保护任务中，系统需要在紧急状态下立即显示警告信息。通过互斥量保护的LVGL调用`lv_obj_clear_flag(guider_ui.main_page_over_voltage_warning_msgbox, LV_OBJ_FLAG_HIDDEN)`，确保了即使在高优先级保护任务中，GUI操作依然保持线程安全，为用户提供及时准确的系统状态反馈。

#### 数据驱动的界面更新策略

界面更新采用完全数据驱动的设计模式，`update_gui_task`任务通过统一的消息队列接收来自各功能模块的数据，根据任务ID和数据描述符将数据路由到对应的界面控件。例如，来自INA226任务的电流数据（`DATA_DESCRIPTION_CURRENT`）自动更新到电流显示标签`main_page_measure_current_label`，编码器任务的设定值（`DATA_DESCRIPTION_SET_CURRENT`）则更新到电流设置控件`main_page_set_current_box`。

这种设计实现了功能模块与界面显示的完全解耦，任何功能模块只需向消息队列发送标准格式的数据，无需关心具体的界面实现细节。同时，界面更新逻辑集中在单一任务中，便于维护和扩展，为系统的模块化设计奠定了坚实的基础。

综合而言，本电子负载项目的软件系统通过精心设计的多任务架构、高效的通信机制以及严谨的算法实现，构建了一套功能完备、性能优异、安全可靠的嵌入式控制系统，充分体现了现代嵌入式软件工程的先进理念和最佳实践。


## 产品结构设计


为提升本电子负载系统的集成度、工程实用性与设计美学，我们团队致力于将其打造为一款具备市场竞争力的产品。为此，我们采用三维设计工具 Solidworks，针对最终优化集成的「控制-功率」一体化印刷电路板（PCB），精心设计了定制化外壳。整体结构设计不仅关注功能实现，亦充分考量了物理装配的便捷性、结构的稳固性以及用户交互体验。

### 一、整体结构件与接口介绍

本电子负载的机械结构主要由**前盖面板组件**、**中层核心框架**及**后部散热与接口模块**三大部分构成。各部分通过精密配合与模块化设计，实现了高效装配与稳固的整体结构。

**前盖面板组件**，集成了用户交互的核心元素，适配了420x320尺寸的 LCD 显示屏、操作按键、编码器及状态指示灯，并对外壳的整体美观性负责。

**中层核心框架** 作为系统的主承载结构，用于固定「控制-功率」一体化PCB，并集成各类电源输入/输出功率接口（xt60、xt30、DC 座、 香蕉座）

**后部散热与接口模块** 主要容纳主动散热系统组件（3510 径向风扇和对应散热片），并提供 USB 接口给设备供电

在装配工艺上，我们特别注重提升产品的整体性和美观度。例如，在前盖面板内部预埋了方形螺母，用于与固定PCB的中层框架进行连接，从而实现了产品外表面无可见螺丝的简洁设计，显著提升了视觉效果与用户体验。

### 二、前盖面板组件设计

前面板区域作为用户与设备交互的主要界面，其结构设计充分考虑了操作便捷性与信息显示的清晰度

在前盖的左半部分精确适配并包覆住 LCD 显示屏，对LCD屏体形成物理保护

前盖的右半部分则设计了一个下沉的平面来安装亚克力面板，在亚克力材质的面板上，集成了旋转编码器和多个功能按键，方便用户进行参数设置与功能选择。
        
为提升按键操作的准确性和手感，主要功能按键区域设计了引导线槽。

并搭配 WS2812 驱动的彩色 LED 状态指示灯与导光柱，确保状态信息在各种环境光下的可视性

### 三、中层核心框架设计

中层核心框架是系统内部组件的“骨架”，其设计重点在于 PCB 的稳定固定与功率连接的可靠性：

在进行 PCB 固定的中间层，我们配合板子的 layout 和元件布局，设置了合适的加强筋和支撑点，增强 PCB 在受到外部冲击或振动时的抗变形能力，使得产品在使用过程中出现碰撞时，PCB 也不易变形，增强了整体的结构强度和运行可靠性。

又在侧边表面以及圆弧过渡区设置了防滑条和防摩擦保护圈，防止在使用或者携带的过程中出现滑动或摩擦损伤，进一步提升了产品的可靠性和耐用性。

还结合了散热片和径向风扇的安装位置，设计了对应的散热出风风道和引导线

而中层框架还集成了多种电子负载接入电源回路的功率接口，所以又专门在经常需要进行插拔的功率接口位置周边特别设计了不少加强筋和额外的结构支撑，提高了产品的可靠性和耐用性。

### 四、后部散热与接口模块设计


为确保电子负载在高功率密度下能够长期稳定运行，散热系统的设计是本结构方案的核心考量之一

我们在散热片的选型上进行了基本的热兼容评估，综合考虑了材料导热系数、鳍片结构与有效散热面积，并据此设计了散热与风道系统。


并且在设计 PCB 板子的时候，考虑到要使得产品尽量轻薄，并且要兼顾散热和风道的效率，为在有限空间内实现高效散热并尽可能减小产品厚度，我们创新性地采用了长引脚封装的功率 MOSFET，并将其引脚进行 90 度精确弯折

还在 PCB 上在 MOSFET 倒下之后的对应位置开了一个对应散热片尺寸的矩形孔位，配合安装在 90° 弯曲的 mos 管上

这种布局配合强劲的径向风扇，形成了从特定进风口吸入冷空气，空气流经散热片表面（为 MOSFET 降温），最终由中层框架出风口排出的高效、定向散热风道。此设计不仅保证了优异的散热性能，还有效控制了产品的整体尺寸，使其更为轻薄

通过对风扇的风压、风量特性曲线以及散热片热阻的理论估算，并结合实际工况测试，对系统的整体热管理能力进行了验证。
  
实际测试数据表明，在电子负载以 2A 电流满负荷运行时，关键发热部件（如MOSFET）的最高峰值温度控制在 71℃ 左右，确保了系统的热安全裕量和长期运行的可靠性。


