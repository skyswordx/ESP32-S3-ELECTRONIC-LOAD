# LQRæ•°å­¦åŸç†è¯¦è§£ï¼šä»ç†è®ºåˆ°å®ç°

## ğŸ“– ç›®å½•
1. [æ•°å­¦åŸºç¡€](#-æ•°å­¦åŸºç¡€)
2. [æœ€ä¼˜æ§åˆ¶ç†è®º](#-æœ€ä¼˜æ§åˆ¶ç†è®º)
3. [Riccatiæ–¹ç¨‹æ±‚è§£](#-riccatiæ–¹ç¨‹æ±‚è§£)
4. [ç”µå­è´Ÿè½½å»ºæ¨¡](#-ç”µå­è´Ÿè½½å»ºæ¨¡)
5. [ç¨³å®šæ€§åˆ†æ](#-ç¨³å®šæ€§åˆ†æ)
6. [ä»£ç å®ç°å¯¹ç…§](#-ä»£ç å®ç°å¯¹ç…§)

## ğŸ“ æ•°å­¦åŸºç¡€

### çŠ¶æ€ç©ºé—´è¡¨ç¤º

çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´æ¨¡å‹ï¼š

```
è¿ç»­æ—¶é—´ç³»ç»Ÿï¼š
áº‹(t) = Ax(t) + Bu(t)
y(t) = Cx(t)

ç¦»æ•£æ—¶é—´ç³»ç»Ÿï¼š
x(k+1) = Ax(k) + Bu(k)
y(k) = Cx(k)
```

**ç¬¦å·å«ä¹‰ï¼š**
- `x(k)` âˆˆ â„â¿ï¼šçŠ¶æ€å‘é‡
- `u(k)` âˆˆ â„áµï¼šæ§åˆ¶è¾“å…¥å‘é‡
- `y(k)` âˆˆ â„áµ–ï¼šè¾“å‡ºå‘é‡
- `A` âˆˆ â„â¿Ë£â¿ï¼šçŠ¶æ€è½¬ç§»çŸ©é˜µ
- `B` âˆˆ â„â¿Ë£áµï¼šæ§åˆ¶è¾“å…¥çŸ©é˜µ
- `C` âˆˆ â„áµ–Ë£â¿ï¼šè¾“å‡ºçŸ©é˜µ

### ç”µå­è´Ÿè½½çŠ¶æ€ç©ºé—´å»ºæ¨¡

å¯¹äºç”µå­è´Ÿè½½æ’æµæ§åˆ¶ç³»ç»Ÿï¼Œæˆ‘ä»¬å®šä¹‰ï¼š

#### çŠ¶æ€å˜é‡é€‰æ‹©
```
xâ‚(k) = e(k) = r(k) - y(k)           // ç”µæµè¯¯å·®
xâ‚‚(k) = Ä—(k) = [e(k) - e(k-1)]/dt    // è¯¯å·®å˜åŒ–ç‡
xâ‚ƒ(k) = âˆ«e(Ï„)dÏ„                      // è¯¯å·®ç§¯åˆ†
```

#### çŠ¶æ€æ–¹ç¨‹æ¨å¯¼

**è¯¯å·®åŠ¨æ€æ–¹ç¨‹ï¼š**
```
e(k+1) = r(k+1) - y(k+1)
```

å‡è®¾å‚è€ƒå€¼å˜åŒ–ç¼“æ…¢ï¼š`r(k+1) â‰ˆ r(k)`

æ ¹æ®ç³»ç»ŸåŠ¨æ€ç‰¹æ€§ï¼š
```
y(k+1) = ay(k) + bu(k)
```

å› æ­¤ï¼š
```
e(k+1) = r(k) - ay(k) - bu(k)
       = r(k) - a[r(k) - e(k)] - bu(k)
       = (1-a)r(k) + ae(k) - bu(k)
```

åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–ï¼ˆrä¸ºå¸¸æ•°ï¼‰ï¼š
```
e(k+1) â‰ˆ ae(k) - bu(k)
```

**å®Œæ•´çŠ¶æ€æ–¹ç¨‹ï¼š**
```
[e(k+1)    ]   [1  dt  0] [e(k)    ]   [0 ]
[Ä—(k+1)    ] = [0  a   0] [Ä—(k)    ] + [b ] u(k)
[âˆ«e(k+1)   ]   [1  0   1] [âˆ«e(k)   ]   [0 ]
```

å…¶ä¸­ï¼š
- `dt`ï¼šé‡‡æ ·å‘¨æœŸ
- `a`ï¼šç³»ç»Ÿæç‚¹ï¼ˆ0 < a < 1ï¼‰
- `b`ï¼šæ§åˆ¶å¢ç›Šï¼ˆb > 0ï¼‰

## ğŸ¯ æœ€ä¼˜æ§åˆ¶ç†è®º

### æ€§èƒ½æŒ‡æ ‡å‡½æ•°

LQRçš„ç›®æ ‡æ˜¯æœ€å°åŒ–äºŒæ¬¡å‹æ€§èƒ½æŒ‡æ ‡ï¼š

**æ— é™æ—¶åŸŸLQRï¼š**
```
J = Î£(k=0 to âˆ) [x(k)áµ€Qx(k) + u(k)áµ€Ru(k)]
```

**æœ‰é™æ—¶åŸŸLQRï¼š**
```
J = x(N)áµ€Sx(N) + Î£(k=0 to N-1) [x(k)áµ€Qx(k) + u(k)áµ€Ru(k)]
```

**æƒé‡çŸ©é˜µè¦æ±‚ï¼š**
- `Q â‰¥ 0`ï¼ˆåŠæ­£å®šï¼‰ï¼šçŠ¶æ€æƒé‡çŸ©é˜µ
- `R > 0`ï¼ˆæ­£å®šï¼‰ï¼šæ§åˆ¶æƒé‡çŸ©é˜µ
- `S â‰¥ 0`ï¼ˆåŠæ­£å®šï¼‰ï¼šç»ˆç«¯æƒé‡çŸ©é˜µ

### ç”µå­è´Ÿè½½æ€§èƒ½æŒ‡æ ‡è®¾è®¡

```
J = Î£(k=0 to âˆ) [qâ‚e(k)Â² + qâ‚‚Ä—(k)Â² + qâ‚ƒ(âˆ«e)Â² + ru(k)Â²]
```

**ç‰©ç†æ„ä¹‰ï¼š**
- `qâ‚eÂ²`ï¼šæƒ©ç½šç”µæµè·Ÿè¸ªè¯¯å·®
- `qâ‚‚Ä—Â²`ï¼šæƒ©ç½šç”µæµå˜åŒ–ç‡ï¼ˆå¢åŠ é˜»å°¼ï¼‰
- `qâ‚ƒ(âˆ«e)Â²`ï¼šæƒ©ç½šç¨³æ€è¯¯å·®
- `ruÂ²`ï¼šæƒ©ç½šæ§åˆ¶èƒ½é‡æ¶ˆè€—

**æƒé‡çŸ©é˜µå½¢å¼ï¼š**
```
Q = [qâ‚  0   0 ]     R = [r]
    [0   qâ‚‚  0 ]
    [0   0   qâ‚ƒ]
```

### æœ€ä¼˜æ§åˆ¶å¾‹æ¨å¯¼

ä½¿ç”¨**åŠ¨æ€è§„åˆ’åŸç†**ï¼Œå®šä¹‰å€¼å‡½æ•°ï¼š
```
V(x,k) = min{u(k),...,u(âˆ)} Î£(j=k to âˆ) [x(j)áµ€Qx(j) + u(j)áµ€Ru(j)]
```

**Bellmanæ–¹ç¨‹ï¼š**
```
V(x,k) = min{u(k)} [x(k)áµ€Qx(k) + u(k)áµ€Ru(k) + V(Ax(k)+Bu(k), k+1)]
```

å‡è®¾å€¼å‡½æ•°ä¸ºäºŒæ¬¡å‹ï¼š
```
V(x,k) = x(k)áµ€P(k)x(k)
```

å°†æ­¤å½¢å¼ä»£å…¥Bellmanæ–¹ç¨‹ï¼Œé€šè¿‡å˜åˆ†æ³•æ±‚æœ€ä¼˜æ§åˆ¶ï¼š
```
âˆ‚/âˆ‚u [x(k)áµ€Qx(k) + u(k)áµ€Ru(k) + (Ax(k)+Bu(k))áµ€P(k+1)(Ax(k)+Bu(k))] = 0
```

å¾—åˆ°æœ€ä¼˜æ§åˆ¶å¾‹ï¼š
```
u*(k) = -K(k)x(k)
```

å…¶ä¸­å¢ç›ŠçŸ©é˜µï¼š
```
K(k) = (R + Báµ€P(k+1)B)â»Â¹Báµ€P(k+1)A
```

## ğŸ”„ Riccatiæ–¹ç¨‹æ±‚è§£

### ç¦»æ•£ä»£æ•°Riccatiæ–¹ç¨‹ï¼ˆDAREï¼‰

å¯¹äºæ— é™æ—¶åŸŸé—®é¢˜ï¼ŒPçŸ©é˜µæ”¶æ•›åˆ°å¸¸æ•°Pâˆï¼Œæ»¡è¶³ï¼š

```
P = Aáµ€PA - Aáµ€PB(R + Báµ€PB)â»Â¹Báµ€PA + Q
```

è¿™å°±æ˜¯**ç¦»æ•£ä»£æ•°Riccatiæ–¹ç¨‹ï¼ˆDAREï¼‰**ã€‚

### è¿­ä»£æ±‚è§£ç®—æ³•

**ç®—æ³•1ï¼šç›´æ¥è¿­ä»£æ³•**
```
1. åˆå§‹åŒ–ï¼šPâ‚€ = Q
2. è¿­ä»£ï¼šPâ‚–â‚Šâ‚ = Aáµ€Pâ‚–A - Aáµ€Pâ‚–B(R + Báµ€Pâ‚–B)â»Â¹Báµ€Pâ‚–A + Q
3. æ”¶æ•›åˆ¤æ–­ï¼š||Pâ‚–â‚Šâ‚ - Pâ‚–|| < Îµ
```

**ä»£ç å®ç°ï¼š**
```cpp
bool solveLQRRiccati() {
    std::vector<std::vector<T>> P = Q;  // åˆå§‹åŒ–
    
    for (int iter = 0; iter < max_iterations; ++iter) {
        // è®¡ç®— Báµ€PB + R
        auto BT_P_B_R = computeBTPB_R(P);
        
        // è®¡ç®— (Báµ€PB + R)â»Â¹
        auto inv_BT_P_B_R = matrixInverse(BT_P_B_R);
        
        // è®¡ç®— Aáµ€PA
        auto AT_P_A = computeATPB(P);
        
        // è®¡ç®—ä¿®æ­£é¡¹
        auto correction = computeCorrection(P, inv_BT_P_B_R);
        
        // æ›´æ–° P
        auto P_new = AT_P_A - correction + Q;
        
        // æ£€æŸ¥æ”¶æ•›
        if (isConverged(P, P_new)) {
            computeGain(P_new, inv_BT_P_B_R);
            return true;
        }
        
        P = P_new;
    }
    return false;
}
```

### å¢ç›ŠçŸ©é˜µè®¡ç®—

ä¸€æ—¦Riccatiæ–¹ç¨‹æ”¶æ•›ï¼Œè®¡ç®—å¢ç›ŠçŸ©é˜µï¼š
```
K = (R + Báµ€PB)â»Â¹Báµ€PA
```

**ç”µå­è´Ÿè½½ç³»ç»Ÿçš„å¢ç›Šå‘é‡ï¼š**
```cpp
// å¯¹äº3Ã—1ç³»ç»Ÿï¼ŒKæ˜¯1Ã—3å‘é‡
K = [kâ‚  kâ‚‚  kâ‚ƒ]

// æ§åˆ¶å¾‹
u(k) = -kâ‚e(k) - kâ‚‚Ä—(k) - kâ‚ƒâˆ«e(k)
```

è¿™ç›¸å½“äºä¸€ä¸ª**å¢å¼ºå‹PIDæ§åˆ¶å™¨**ï¼š
- `kâ‚`ï¼šæ¯”ä¾‹å¢ç›Šï¼ˆç±»ä¼¼Kpï¼‰
- `kâ‚‚`ï¼šå¾®åˆ†å¢ç›Šï¼ˆç±»ä¼¼Kdï¼‰
- `kâ‚ƒ`ï¼šç§¯åˆ†å¢ç›Šï¼ˆç±»ä¼¼Kiï¼‰

ä½†ä¸ä¼ ç»ŸPIDä¸åŒï¼Œè¿™äº›å¢ç›Šæ˜¯é€šè¿‡**æ•°å­¦ä¼˜åŒ–**å¾—åˆ°çš„æœ€ä¼˜å€¼ï¼

## ğŸ“Š ç”µå­è´Ÿè½½å»ºæ¨¡

### ç³»ç»Ÿè¾¨è¯†

ç”µå­è´Ÿè½½ç³»ç»Ÿå¯å»ºæ¨¡ä¸ºä¸€é˜¶ç³»ç»Ÿï¼š
```
G(s) = b/(s - a)
```

**ç¦»æ•£åŒ–ï¼ˆé›¶é˜¶ä¿æŒå™¨ï¼‰ï¼š**
```
G(z) = b(1-e^(aT))/(z - e^(aT))
```

å…¶ä¸­Tä¸ºé‡‡æ ·å‘¨æœŸã€‚

### å‚æ•°ä¼°è®¡

**æ–¹æ³•1ï¼šé˜¶è·ƒå“åº”**
```cpp
void systemIdentification() {
    // æ–½åŠ é˜¶è·ƒè¾“å…¥
    setDAC(2.0);  // 2Vé˜¶è·ƒ
    
    // è®°å½•å“åº”
    std::vector<double> response;
    for (int i = 0; i < 100; ++i) {
        response.push_back(readCurrent());
        delay(10);  // 10msé‡‡æ ·
    }
    
    // æ‹Ÿåˆä¸€é˜¶æ¨¡å‹
    auto [a, b] = fitFirstOrderModel(response);
    
    Serial.printf("Identified parameters: a=%.4f, b=%.4f\n", a, b);
}
```

**æ–¹æ³•2ï¼šæœ€å°äºŒä¹˜è¾¨è¯†**
```
è®¾ï¼šy(k) = ay(k-1) + bu(k-1) + Îµ(k)

çŸ©é˜µå½¢å¼ï¼šY = Î¦Î¸ + E

å…¶ä¸­ï¼š
Y = [y(2), y(3), ..., y(N)]áµ€
Î¦ = [y(1) u(1)]
    [y(2) u(2)]
    [... ...]
    [y(N-1) u(N-1)]
Î¸ = [a, b]áµ€

æœ€å°äºŒä¹˜è§£ï¼šÎ¸Ì‚ = (Î¦áµ€Î¦)â»Â¹Î¦áµ€Y
```

### æ¨¡å‹éªŒè¯

```cpp
bool validateModel(double a, double b) {
    // æ£€æŸ¥ç¨³å®šæ€§
    if (abs(a) >= 1.0) {
        Serial.println("Warning: System unstable!");
        return false;
    }
    
    // æ£€æŸ¥å¢ç›Šåˆç†æ€§
    if (b <= 0 || b > 1.0) {
        Serial.println("Warning: Unreasonable gain!");
        return false;
    }
    
    // æ£€æŸ¥å¯æ§æ€§
    // å¯¹äºç”µå­è´Ÿè½½ç³»ç»Ÿï¼Œé€šå¸¸æ˜¯å¯æ§çš„
    
    return true;
}
```

## ğŸ“ˆ ç¨³å®šæ€§åˆ†æ

### é—­ç¯ç³»ç»Ÿç¨³å®šæ€§

LQRé—­ç¯ç³»ç»Ÿï¼š
```
x(k+1) = (A - BK)x(k)
```

**ç¨³å®šæ€§æ¡ä»¶ï¼š**
çŸ©é˜µ(A - BK)çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½åœ¨å•ä½åœ†å†…ï¼š
```
|Î»áµ¢(A - BK)| < 1,  âˆ€i
```

### LQRç¨³å®šæ€§ä¿è¯

**å®šç†ï¼š** å¦‚æœç³»ç»Ÿ(A,B)å¯æ§ï¼Œåˆ™LQRæ§åˆ¶å™¨ä¿è¯é—­ç¯ç³»ç»Ÿç¨³å®šã€‚

**è¯æ˜æ€è·¯ï¼š**
1. å¯æ§æ€§ä¿è¯Riccatiæ–¹ç¨‹æœ‰å”¯ä¸€æ­£å®šè§£
2. æ­£å®šè§£ä¿è¯å¢ç›ŠçŸ©é˜µä½¿é—­ç¯ç³»ç»Ÿç¨³å®š
3. LQRçš„æœ€ä¼˜æ€§ä¿è¯äº†æœ€ä½³çš„ç¨³å®šè£•åº¦

### é²æ£’æ€§åˆ†æ

LQRå…·æœ‰ä¼˜ç§€çš„é²æ£’æ€§ï¼š

**å¢ç›Šè£•åº¦ï¼š** æ— ç©·å¤§
**ç›¸ä½è£•åº¦ï¼š** è‡³å°‘60Â°

```cpp
void analyzeRobustness() {
    // è®¡ç®—é—­ç¯æç‚¹
    auto A_cl = A - B * K;
    auto poles = eigenvalues(A_cl);
    
    Serial.println("Closed-loop poles:");
    for (auto pole : poles) {
        Serial.printf("  %.4f + %.4fj (magnitude: %.4f)\n", 
                     pole.real(), pole.imag(), abs(pole));
    }
    
    // æ£€æŸ¥ç¨³å®šæ€§
    bool stable = true;
    for (auto pole : poles) {
        if (abs(pole) >= 1.0) {
            stable = false;
            break;
        }
    }
    
    Serial.printf("System is %s\n", stable ? "STABLE" : "UNSTABLE");
}
```

## ğŸ’» ä»£ç å®ç°å¯¹ç…§

### æ•°å­¦å…¬å¼ä¸ä»£ç å¯¹ç…§

#### 1. çŠ¶æ€æ›´æ–°

**æ•°å­¦å…¬å¼ï¼š**
```
x(k+1) = Ax(k) + Bu(k)
```

**ä»£ç å®ç°ï¼š**
```cpp
void updateStates() {
    // è®¡ç®—æ–°çš„è¯¯å·®
    T current_error = process_variable.target - process_variable.measure;
    
    // çŠ¶æ€å‘é‡æ›´æ–°
    std::vector<T> prev_state = process_variable.state;
    
    // xâ‚ = error
    process_variable.state[0] = current_error;
    
    // xâ‚‚ = error_rate = (e(k) - e(k-1))/dt
    T dt = static_cast<T>(sampling_time);
    process_variable.state[1] = (current_error - prev_state[0]) / dt;
    
    // xâ‚ƒ = integral = integral(k-1) + e(k)*dt
    process_variable.state[2] = prev_state[2] + current_error * dt;
}
```

#### 2. æ§åˆ¶å¾‹è®¡ç®—

**æ•°å­¦å…¬å¼ï¼š**
```
u(k) = -Kx(k) = -[kâ‚ kâ‚‚ kâ‚ƒ][e(k), Ä—(k), âˆ«e(k)]áµ€
```

**ä»£ç å®ç°ï¼š**
```cpp
void computeLQRControl() {
    T control_output = T{0};
    
    // u = -K * x
    for (size_t i = 0; i < process_variable.K.size(); ++i) {
        control_output -= process_variable.K[i] * process_variable.state[i];
    }
    
    process_variable.output = control_output;
}
```

#### 3. Riccatiæ–¹ç¨‹æ±‚è§£

**æ•°å­¦å…¬å¼ï¼š**
```
P = Aáµ€PA - Aáµ€PB(R + Báµ€PB)â»Â¹Báµ€PA + Q
```

**ä»£ç å®ç°ï¼š**
```cpp
bool solveLQRRiccati() {
    // åˆå§‹åŒ– P = Q
    std::vector<std::vector<T>> P = process_variable.Q;
    
    for (int iter = 0; iter < max_iterations; ++iter) {
        // è®¡ç®— B^T * P * B + R
        auto BT_P_B_R = computeBTPB_plusR(P);
        
        // è®¡ç®—é€†çŸ©é˜µ
        auto inv_BT_P_B_R = matrixInverse(BT_P_B_R);
        
        // è®¡ç®— A^T * P * A
        auto AT_P_A = computeATPB(P);
        
        // è®¡ç®—ä¿®æ­£é¡¹
        auto correction = computeCorrection(P, inv_BT_P_B_R);
        
        // æ›´æ–° P_new = A^T*P*A - correction + Q
        auto P_new = matrixAdd(matrixSubtract(AT_P_A, correction), Q);
        
        // æ£€æŸ¥æ”¶æ•›
        if (checkConvergence(P, P_new)) {
            computeLQRGain(P_new, inv_BT_P_B_R);
            return true;
        }
        
        P = P_new;
    }
    
    return false; // æœªæ”¶æ•›
}
```

### æ•°å€¼è®¡ç®—æ³¨æ„äº‹é¡¹

#### 1. æ•°å€¼ç¨³å®šæ€§
```cpp
// é¿å…çŸ©é˜µå¥‡å¼‚
if (std::abs(determinant(BT_P_B_R)) < 1e-12) {
    Serial.println("Warning: Matrix near singular!");
    return false;
}

// ä½¿ç”¨æ•°å€¼ç¨³å®šçš„ç®—æ³•
auto inv = matrixInverse_SVD(BT_P_B_R);  // SVDåˆ†è§£æ±‚é€†
```

#### 2. æ”¶æ•›åˆ¤æ–­
```cpp
bool checkConvergence(const Matrix& P_old, const Matrix& P_new) {
    T max_diff = T{0};
    
    for (size_t i = 0; i < P_old.size(); ++i) {
        for (size_t j = 0; j < P_old[i].size(); ++j) {
            T diff = std::abs(P_new[i][j] - P_old[i][j]);
            max_diff = std::max(max_diff, diff);
        }
    }
    
    return max_diff < convergence_tolerance;
}
```

#### 3. æ•°å€¼ç²¾åº¦
```cpp
// ä½¿ç”¨doubleè€Œéfloat
using T = double;  // æ¨è

// è®¾ç½®åˆé€‚çš„å®¹å·®
const T convergence_tolerance = 1e-8;

// é™åˆ¶è¿­ä»£æ¬¡æ•°é˜²æ­¢æ— é™å¾ªç¯
const int max_iterations = 100;
```

## ğŸ¯ æ€»ç»“

LQRæ§åˆ¶å™¨çš„æ•°å­¦åŸºç¡€ä½“ç°äº†ç°ä»£æ§åˆ¶ç†è®ºçš„ä¼˜é›…ï¼š

### ğŸ”¬ ç†è®ºä¼˜åŠ¿
1. **æœ€ä¼˜æ€§ä¿è¯**ï¼šæ•°å­¦ä¸Šçš„æœ€ä¼˜è§£
2. **ç¨³å®šæ€§ä¿è¯**ï¼šå¯æ§ç³»ç»Ÿå¿…ç„¶ç¨³å®š
3. **é²æ£’æ€§ä¼˜ç§€**ï¼šå¤©ç„¶çš„å¢ç›Šå’Œç›¸ä½è£•åº¦
4. **è®¾è®¡ç³»ç»Ÿ**ï¼šåŸºäºçŠ¶æ€ç©ºé—´çš„ç§‘å­¦è®¾è®¡

### ğŸ’» å®ç°ç‰¹ç‚¹
1. **è®¡ç®—å¤æ‚åº¦**ï¼šO(nÂ³)çš„åˆå§‹åŒ– + O(n)çš„è¿è¡Œæ—¶
2. **å­˜å‚¨éœ€æ±‚**ï¼šä¸»è¦æ˜¯å¢ç›Šå‘é‡K
3. **æ•°å€¼ç¨³å®š**ï¼šéœ€è¦æ³¨æ„çŸ©é˜µè¿ç®—çš„æ•°å€¼é—®é¢˜
4. **å‚æ•°è°ƒèŠ‚**ï¼šé€šè¿‡Qã€RçŸ©é˜µè°ƒèŠ‚æ€§èƒ½

### ğŸ¯ åº”ç”¨å‰æ™¯
åœ¨ç”µå­è´Ÿè½½ç³»ç»Ÿä¸­ï¼ŒLQRæä¾›äº†PIDå’ŒMPCä¹‹é—´çš„æœ€ä½³å¹³è¡¡ï¼š
- æ¯”PIDæ›´ç§‘å­¦ï¼ˆæœ€ä¼˜æ€§ï¼‰
- æ¯”MPCæ›´ç®€å•ï¼ˆæ— çº¦æŸä¼˜åŒ–ï¼‰
- å®æ—¶æ€§ä¼˜ç§€ï¼ˆæ— åœ¨çº¿ä¼˜åŒ–ï¼‰

é€šè¿‡æ·±å…¥ç†è§£LQRçš„æ•°å­¦åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¥½åœ°è°ƒå‚å’Œä¼˜åŒ–æ§åˆ¶å™¨æ€§èƒ½ï¼
